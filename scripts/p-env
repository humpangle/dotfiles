#!/usr/bin/env bash
# shellcheck disable=2034,2209,2135,2155,2046,2251
# More safety, by turning some bugs into errors.
# Without `errexit` you don’t need ! and can replace
# ${PIPESTATUS[0]} with a simple $?, but I prefer safety.
set -o errexit
set -o pipefail
set -o noclobber
set -o nounset

usage() {
  echo "Usage: parse-args [ -s | --string ]
                  [ -f | --format yaml|yml ]
                  [ -o | --output   /some/path ]
                  env-file"
  exit 2
}

out_file=
format=
verbose=
in_file=
string=

function parse-args {
  # -allow a command to fail with !’s side effect on errexit
  # -use return value from ${PIPESTATUS[0]}, because ! hosed $?
  ! getopt --test >/dev/null
  if [[ ${PIPESTATUS[0]} -ne 4 ]]; then
    echo "I’m sorry, $(getopt --test) failed in this environment."
    exit 1
  fi

  # option --output/-o requires 1 argument
  LONGOPTS=format:,output:,verbose
  OPTIONS=sf:o:v

  # -regarding ! and PIPESTATUS see above
  # -temporarily store output to be able to check for errors
  # -activate quoting/enhanced mode (e.g. by writing out “--options”)
  # -pass arguments only via   -- "$@"   to separate them correctly
  ! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name "$0" -- "$@")
  if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
    # e.g. return value is 1
    #  then getopt has complained about wrong arguments to stdout
    usage
  fi

  # read getopt’s output this way to handle the quoting right:
  eval set -- "$PARSED"

  # now enjoy the options in order and nicely split until we see --
  while true; do
    case "$1" in
      -s | --string)
        string=y
        shift
        ;;
      -f | --format)
        format="$2"
        shift 2
        ;;
      -v | --verbose)
        verbose=y
        shift
        ;;
      -o | --output)
        out_file="$2"
        shift 2
        ;;
        # -- means the end of the arguments; drop this, and break out of the
        # while loop
      --)
        shift
        break
        ;;
      *)
        echo "Unexpected option: $1."
        usage
        ;;
    esac
  done

  # handle non-option arguments
  if [[ $# -ne 1 ]]; then
    echo "$0: A single input file is required."
    exit 4
  fi

  in_file=$1
}

parse-args "$@"

if [[ "$in_file" =~ ^/ ]]; then
  env_file_abs_path="$in_file"
else
  env_file_abs_dir="$(
    (cd -- "$(dirname "$in_file")" || exit) >/dev/null 2>&1
    pwd -P
  )"

  env_file_abs_path="$env_file_abs_dir/$in_file"
fi

new_asbolute_file_path="${env_file_abs_path}.n"
rm -rf "${new_asbolute_file_path}"

declare -A env_key_to_value_map=()

line_regex="^[^#]+.+"

# shellcheck disable=2013
while read -r line; do
  if [[ "$line" =~ $line_regex ]]; then
    key=$(echo "$line" | cut -d '=' -f 1)
    val=$(echo "$line" | cut -d'=' -f 2-)

    for line_with_varirables in $(echo "$val" | grep -Po '\$\{\K.+?(?=\})'); do
      variable_text="\${$line_with_varirables}"
      variable_val="${env_key_to_value_map[$line_with_varirables]:-}"

      if [[ -z "$variable_val" ]]; then
        variable_val=${!line_with_varirables}
      fi

      val="${val//$variable_text/$variable_val}"
    done

    env_key_to_value_map["$key"]="${val}"
  fi
done <<<$(cat "$env_file_abs_path")

env_key_to_value_map["ENV_FILE"]="${new_asbolute_file_path}"

if [[ -n "$out_file" ]]; then
  new_asbolute_file_path=$(realpath "$out_file")
fi

if [[ -z "$string" ]]; then
  rm -rf "$new_asbolute_file_path"
  touch "$new_asbolute_file_path"
fi

text=

for key in "${!env_key_to_value_map[@]}"; do
  val="${env_key_to_value_map[$key]}"

  if [[ -z "$val" ]]; then
    continue
  fi

  out="${key}=${val}"

  if [[ "$format" = yml ]] || [[ "$format" = yaml ]]; then
    out="${key}: ${env_key_to_value_map[$key]}"
  fi

  if [[ -n "${string}" ]]; then
    text="$out $text"
  else
    echo "$out" >>"$new_asbolute_file_path"
  fi
done

if [[ -z "$string" ]]; then
  touch "$new_asbolute_file_path"
  sort "$new_asbolute_file_path" -o "$new_asbolute_file_path"
else
  echo "$text"
fi
