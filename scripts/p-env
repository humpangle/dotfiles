#!/usr/bin/env bash
# shellcheck disable=2034,2209,2135,2155,2046,2251
# More safety, by turning some bugs into errors.
# Without `errexit` you don’t need ! and can replace
# ${PIPESTATUS[0]} with a simple $?, but I prefer safety.
set -o errexit
set -o pipefail
set -o noclobber
# set -o nounset

usage() {
  echo "Usage: p-env [ -s | --string ]
                  [ --cwd some/path ]
                  [ -e | --exec 'command' ]
                  [ -f | --format yaml|yml ]
                  [ -o | --output   /some/path ]
                  [ -d | --debug ]
                  [ -n | --no-change-name ]
                  [ -a | --env-name 'name-for-env-file' ]
                  env-file"
  exit "${1:-2}"
}

out_file=
format=
verbose=
in_file=
_in_string=
string=
exec_cmd=
cwd=
debug=
no_change_name=
new_env_name=

function parse-args {
  # -allow a command to fail with !’s side effect on errexit
  # -use return value from ${PIPESTATUS[0]}, because ! hosed $?
  ! getopt --test >/dev/null
  if [[ ${PIPESTATUS[0]} -ne 4 ]]; then
    echo "I’m sorry, $(getopt --test) failed in this environment."
    exit 1
  fi

  # options:
  #   --format/f  requires 1 argument
  #   --output/-o requires 1 argument
  #   --exec/-e   requires 1 argument
  #   --cwd       requires 1 argument
  #   string/s
  #   debug/d
  #   verbose/v
  #   no-change-name/n
  long_options=string,debug,format:,output:,exec:,cwd:,verbose,no-change-name,env-name:
  short_options=sdf:o:e:v,n,a:

  # -regarding ! and PIPESTATUS see above
  # -temporarily store output to be able to check for errors
  # -activate quoting/enhanced mode (e.g. by writing out “--options”)
  # -pass arguments only via   -- "$@"   to separate them correctly
  ! parsed_output=$(getopt --options=$short_options --longoptions=$long_options --name="$0" -- "$@")
  if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
    # e.g. return value is 1
    #  then getopt has complained about wrong arguments to stdout
    usage
  fi

  # read getopt’s output this way to handle the quoting right:
  eval set -- "$parsed_output"

  # now enjoy the options in order and nicely split until we see --
  while true; do
    case "$1" in
      -s | --string)
        string=y
        shift
        ;;

      -d | --debug)
        debug=y
        shift
        ;;

      -f | --format)
        format="$2"
        shift 2
        ;;

      -n | --no-change-name)
        no_change_name=y
        shift
        ;;

      -v | --verbose)
        verbose=y
        shift
        ;;

      -o | --output)
        out_file="$2"
        shift 2
        ;;

      -e | --exec)
        exec_cmd="$2"
        shift 2
        ;;

      --cwd)
        cwd="$2"
        shift 2
        ;;

      --env-name | -a)
        new_env_name="$2"
        shift 2
        ;;

        # -- means the end of the arguments; drop this, and break out of the
        # while loop
      --)
        shift
        break
        ;;

      *)
        echo "Unexpected option: $1."
        usage
        ;;
    esac
  done

  # handle non-option arguments
  if [[ $# -ne 1 ]]; then
    echo "$0: File containing environment variable is required."
    usage 4
  fi

  in_file=$1
}

function no-write-to-file {
  [[ -n "${string}" ]] || [[ -n "$exec_cmd" ]] && echo "1"
}

function _write-env-filename {
  local -n arr=$1

  local names=(
    ENV_FILENAME
    ENV_FILE
  )

  for _name in "${names[@]}"; do
    # shellcheck disable=2076
    if [[ "${_in_string}" =~ "${_name}=" ]]; then
      arr["${_name}"]=$2
    fi
  done
}

parse-args "$@"

in_path="$(realpath "$in_file")"
_in_string="$(cat "$in_path")"

out_path="${in_path}.n"

declare -A env_key_to_value_map=()

line_regex="^[^#]+.+"

while read -r line; do
  if [[ "$line" =~ $line_regex ]]; then
    key=$(echo "$line" | cut -d '=' -f 1)
    val=$(echo "$line" | cut -d'=' -f 2-)

    [[ -n "$debug" ]] && echo "$key=$val"

    for line_with_varirables in $(echo "$val" | grep -Po '\$\{\K.+?(?=\})'); do
      variable_text="\${$line_with_varirables}"
      variable_val="${env_key_to_value_map[$line_with_varirables]:-}"

      if [[ -z "$variable_val" ]]; then
        variable_val=${!line_with_varirables}
      fi

      val="${val//$variable_text/$variable_val}"
    done

    env_key_to_value_map["$key"]="${val}"
  fi
done <<<"${_in_string}"

if [[ -n "$out_file" ]]; then
  out_path=$(realpath "$out_file")
fi

if [[ "$(no-write-to-file)" ]]; then
  _write-env-filename env_key_to_value_map "${in_path}"
else
  rm -rf "$out_path"
  touch "$out_path"

  #### Update value of ENV_FILE depending on args
  if [[ -n "${new_env_name}" ]]; then
    # We have a new name, let's use it
    _write-env-filename env_key_to_value_map "${new_env_name}"
  elif [[ -n "$no_change_name" ]]; then
    # We are told not to change the name, so we use input file name
    _write-env-filename env_key_to_value_map "${in_path}"
  else
    # BY default, we set value to output file name
    _write-env-filename env_key_to_value_map "${in_path}"
  fi
fi

text=

for key in "${!env_key_to_value_map[@]}"; do
  val="${env_key_to_value_map[$key]}"

  out="${key}=${val}"

  if [[ "$format" = yml ]] || [[ "$format" = yaml ]]; then
    out="${key}: ${env_key_to_value_map[$key]}"
  fi

  if [[ "$(no-write-to-file)" ]]; then
    text="$out $text"
  else
    echo "$out" >>"$out_path"
  fi
done

if [[ -n "$exec_cmd" ]]; then
  cmd="$text $exec_cmd"

  if [[ -n "$cwd" ]]; then
    cmd="( cd $cwd; $cmd  )"
  fi

  eval "$cmd"
elif [[ -z "$string" ]]; then
  sort "$out_path" -o "$out_path"
else
  echo "$text"
fi
