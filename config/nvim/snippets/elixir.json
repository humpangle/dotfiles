{
  "print to console": {
    "prefix": ["puts", "ioputs"],
    "body": [
      "IO.puts(\"\"\"\n\n\n",
      "${1:label}: \n    #{ inspect( ${2:expr} ) }\n\n\n",
      "\"\"\")"
    ],
    "description": "print to console - puts"
  },

  "inspect console": {
    "prefix": "putsinspect",
    "body": [
      "IO.inspect(${1:data}, label: \"\n----------- ${1:label}------------\n\")",
      "IO.puts(\"-----------end ${1:label}------------\n\")"
    ],
    "description": "print to console puts inspect"
  },

  "inspect with label": {
    "prefix": "inspectlabel",
    "body": [
      "IO.inspect(${1:data}, label: \"\\n----------- ${2:label} ------------\")"
    ],
    "description": "print to console puts inspect"
  },

  "inspect with label in pipe": {
    "prefix": "inspectpipe",
    "body": "|> IO.inspect(label: \"\\n----${1:label}----\\n\")",
    "description": "print to console puts inspect"
  },

  "@opaque type": {
    "prefix": "@opaque",
    "body": "@opaque ${1:t} :: ${2:expr}",
    "description": "@opaque type"
  },

  "@type type": {
    "prefix": "@type",
    "body": "@type ${1:t} :: ${2:type}",
    "description": "@type type"
  },

  "@spec": {
    "prefix": "@spec",
    "body": "@spec ${1:fun_name}(${2:param} :: ${3:type}) :: ${4:return}",
    "description": "function specification"
  },

  "for expression full": {
    "prefix": ["for_exp_full"],
    "body": [
      "for ${1:member1} <- ${2:list1},",
      "    ${3:member2 <- member1_or_list2},",
      "    ${4:var = member1 + member2,}",
      "    ${5:filter_exp,}",
      "    ${6:unique: true,}",
      "    ${7:into: string_or_map} do",
      "  # {key, val}",
      "  ${8:return_exp}",
      "end"
    ],
    "description": "for expression full"
  },

  "for into": {
    "prefix": ["for_into"],
    "body": [
      "for ${1:member1} <- ${2:list1},",
      "    into: ${3:string_or_map} do",
      "  ${4:# code}",
      "end"
    ],
    "description": "for into"
  },

  "for reduce": {
    "prefix": ["for_reduce"],
    "body": [
      "for ${1:member1} <- ${2:list1},",
      "    reduce: ${3:string_or_map_or_collectible} do",
      "  acc -> ${4:expression}",
      "end"
    ],
    "description": "for reduce"
  },

  "defstruct": {
    "prefix": ["defstruct_def"],
    "body": [
      "defstruct [",
      "  :${1:field},",
      "  ${2:# field: default_val}",
      "]"
    ],
    "description": "Defines a Struct"
  },

  "set up test module": {
    "prefix": ["defmodule_test", "test_module"],
    "body": [
      "defmodule ${1:Module.Name}Test do",
      "  use ExUnit.Case, async: ${2:true}",
      "  alias ${1:Module.Name}${3:, as:Name}",
      "",
      "  setup_all  do",
      "    :ok",
      "  end",
      "",
      "  setup _context do",
      "    ${4:# code}",
      "    :ok",
      "  end",
      "",
      "  test \"${5:test name}\" do",
      "    ${6:# code}$0",
      "  end",
      "end"
    ],
    "description": "set up test module"
  },

  "ExUnit capture log": {
    "prefix": ["capture_log_exunit", "exunit_capture_log"],
    "body": [
      "# import ExUnit.CaptureLog",
      "# @moduletag capture_log: true",
      "",
      "_log_message =",
      "  capture_log(fn ->",
      "      ${0:# assertions}",
      "  end)",
      "",
      "# assert log_message =~ \"STACK\""
    ],
    "description": "ExUnit capture log"
  },

  "@behaviour": {
    "prefix": "@behaviour",
    "body": "@behaviour ",
    "description": "@behaviour"
  },

  "Registry": {
    "prefix": "registry",
    "body": [
      "# Add this to supervision: {Registry, keys: :unique, name: ${1:name}}",
      "def ${2:func_name}(${3:param}) do",
      "  {:via, Registry, {${1:name}, ${3:param}}}",
      "end"
    ],
    "description": "Elixir Registry"
  },

  "@module doc": {
    "prefix": ["@module_doc", "module_doc"],
    "body": ["@moduledoc ~S\"\"\"", "  $1", "\"\"\""],
    "description": "@module doc"
  },

  "@module doc false": {
    "prefix": ["@module_doc_false", "module_doc_false"],
    "body": "@moduledoc false",
    "description": "@module doc false"
  },

  "@doc": {
    "prefix": ["doc", "@doc"],
    "body": ["@doc \"\"\"", "$0", "\"\"\""],
    "description": "@doc"
  },

  "@doc Sigil": {
    "prefix": ["@doc_sigil", "doc_sigil"],
    "body": ["@doc ~S\"\"\"", "  $1", "\"\"\""],
    "description": "@doc Sigil"
  },

  "@doc false": {
    "prefix": ["@doc_false", "doc_false"],
    "body": "@doc false",
    "description": "@doc false"
  },

  "DynamicSupervisor spec": {
    "prefix": "supervisor_spec_dynamic",
    "body": [
      "%{",
      "id: ${1:compulsory},",
      "start: {",
      "  DynamicSupervisor, ",
      ":start_link, [[strategy: :one_for_one, name: ${2:compulsory}]]}, ",
      "type: :supervisor",
      "}"
    ],
    "description": "DynamicSupervisor specification"
  },

  "Dynamic Supervisor": {
    "prefix": ["dynamic_supervisor", "supervisor_dynamic"],
    "body": [
      "defmodule ${1:MySupervisor} do",
      "  use DynamicSupervisor",
      "",
      "  @process_name __MODULE__",
      "$0",
      "  ## Client APIs",
      "",
      "  def start_link(init_arg) do",
      "      DynamicSupervisor.start_link(",
      "          # The module which defines init/1 (in this case, this module)",
      "          __MODULE__,",
      "",
      "          # Argument passed to init/1. If there is no argument, just pass the",
      "          # atom `:ok`",
      "          init_arg,",
      "          # Name registration",
      "          name: @process_name",
      "      )",
      "  end",
      "",
      "  def start_child(foo, bar, baz) do",
      "      # If MyWorker is not using the new child specs, we need to pass a map:",
      "      # spec = %{id: MyWorker, start: {MyWorker, :start_link, [foo, bar, baz]}}",
      "      # This is useful if child worker does not follow the `start_link`",
      "      # convention.",
      "",
      "      spec = {",
      "          MyWorker,",
      "          # Argument passed to child worker's `start_link`. If uses function",
      "          # named other than `start_link`, use a spec map as stated above.",
      "          foo: foo, bar: bar, baz: baz",
      "      }",
      "",
      "      DynamicSupervisor.start_child(",
      "          @process_name,",
      "          spec",
      "      )",
      "  end",
      "",
      "  @doc \"\"\"",
      "      Nice utility method to list all processes under supervision",
      "  \"\"\"",
      "  def list_children do",
      "      # [",
      "      #   %{",
      "      #     id: :undefined, # always `:undefined` for dynamic supervisor",
      "      #     child: PID, # or `:restarting` if about to be restarted",
      "      #     type: :worker, # or :supervisor",
      "      #     modules: [] # as defined in child spec",
      "      #   }",
      "      # ]",
      "      DynamicSupervisor.which_children(@process_name)",
      "  end",
      "",
      "  @doc \"\"\"",
      "      Nice utility method to return number of processes under supervision",
      "  \"\"\"",
      "  def count_children do",
      "      # %{active: 2, specs: 2, supervisors: 0, workers: 2}",
      "      DynamicSupervisor.count_children(@process_name)",
      "  end",
      "",
      "  ## Supervisor callbacks",
      "",
      "  @impl true",
      "  def init(init_arg) do",
      "      DynamicSupervisor.init(",
      "          strategy: :one_for_one,",
      "          extra_arguments: [init_arg]",
      "      )",
      "  end",
      "end",
      "",
      "# Add this supervisor to your main supervision tree:",
      "# children = [",
      "#   {",
      "#     MySupervisor,",
      "#     strategy: :one_for_one, name: MySupervisor",
      "#   }",
      "# ]",
      "#",
      "#",
      "# Root Supervisor",
      "# Supervisor.start_link(",
      "#   children,",
      "#   strategy: :one_for_one",
      "# )"
    ],
    "description": "Dynamic Supervisor"
  },
  "Create ecto table": {
    "prefix": "create_table_ecto",
    "body": [
      "create table(:${1:table_name}, primary_key: false) do",
      "  add :id, :binary_id, primary_key: true, comment: \"Primary key\"",
      "  add :source, :string, null: false, default: \"password\", comment: \"source of token\"",
      "  add :token, :string, null: false, comment: \"token from source\"",
      "  add :related_id, references(:relateds, on_delete: :delete_all), null: false, comment: \"The owner of ${1:table_name}\"",
      "",
      "  timestamps(type: :utc_datetime)",
      "end",
      "",
      ":${1:table_name}",
      "|> index([:source, :token])",
      "|> create()",
      "",
      ":${1:table_name}",
      "|> unique_index([:related_id, :source])",
      "|> create()"
    ],
    "description": "Create ecto table"
  },

  "Create ecto schema": {
    "prefix": "create_schema_ecto",
    "body": [
      "defmodule ${1:module_name} do",
      "  use Ecto.Schema, warn: true",
      "",
      "  import Ecto.Changeset",
      "",
      "  alias Ecto.Changeset",
      "",
      "  @primary_key {:id, :binary_id, autogenerate: true}",
      "  @foreign_key_type :binary_id",
      "  schema \"${2:schema_name}\" do",
      "    field(:${3:field_name}, :string)",
      "",
      "    timestamps(type: :utc_datetime)",
      "  end",
      "",
      "  @doc \"changeset\"",
      "  def changeset(%__MODULE__{} = ${4:name}, %{} = ${5:attrs}) do",
      "    ${4:name}",
      "    |> cast(${5:attrs}, [:${3:field_name}])",
      "  end",
      "end"
    ],
    "description": "Create ecto schema"
  },

  "Ecto aliases": {
    "prefix": "ecto_aliases",
    "body": [
      "defp aliases do",
      "  [",
      "    \"ecto.setup\": [\"ecto.create\", \"ecto.migrate\", \"run priv/repo/seeds.exs\"],",
      "    \"ecto.reset\": [\"ecto.drop\", \"ecto.setup\"],",
      "    test: [\"ecto.create --quiet\", \"ecto.migrate\", \"test\"]",
      "  ]",
      "end"
    ],
    "description": "Ecto aliases"
  },

  "elixirc_paths": {
    "prefix": "elixirc_paths",
    "body": [
      "# Specifies which paths to compile per environment.",
      "defp elixirc_paths(:dev), do: [\"lib\"${1:, \"another_path\"}]",
      "defp elixirc_paths(:test), do: elixirc_paths(:dev) ++ [\"test/support\"]",
      "defp elixirc_paths(_), do: [\"lib\"]"
    ],
    "description": "elixirc_paths"
  },

  "absinthe child schema": {
    "prefix": "absinthe_child_schema_definition",
    "body": [
      "defmodule ${1:module_parent}.Schema.${2:module_name} do",
      "  use Absinthe.Schema.Notation",
      "",
      "  alias ${1:module_parent}.${2:module_name}.Resolver",
      "",
      "  @desc \"A ${2:module_name}\"",
      "  object :${3:schema_name} do",
      "      field :id, non_null(:id)",
      "",
      "      field :inserted_at, non_null(:iso_datetime)",
      "      field :updated_at, non_null(:iso_datetime)",
      "  end",
      "",
      "  @desc \"Variables for creating ${2:module_name}\"",
      "  input_object :${3:schema_name} do",
      "      field :name, non_null(:string)",
      "  end",
      "",
      "  @desc \"Mutations allowed on ${2:module_name} object\"",
      "  object :${3:schema_name}_mutation do",
      "      @doc \"Create a ${3:schema_name}\"",
      "      field :field_input, :${3:schema_name} do",
      "          arg :field_input, non_null(:field_input)",
      "",
      "          resolve(&Resolver.create/3)",
      "      end",
      "  end",
      "",
      "  @desc \"Queries allowed on ${2:module_name} object\"",
      "  object :${3:schema_name}_query do",
      "      @desc \"query a ${3:schema_name} \"",
      "      field :field, :${3:schema_name} do",
      "          arg :field, non_null(:field_input)",
      "          resolve(&Resolver.field/3)",
      "      end",
      "  end",
      "end"
    ],
    "description": "absinthe child schema definition"
  },

  "absinthe schema": {
    "prefix": "absinthe_schema_definition",
    "body": [
      "defmodule ${1:module_name}.Schema do",
      "  use Absinthe.Schema",
      "",
      "  import_types(Absinthe.Type.Custom)",
      "  import_types(${1:module_name}.Schema.Types)",
      "",
      "",
      "  query do",
      "      import_fields :${2:child}_query",
      "  end",
      "",
      "  mutation do",
      "      import_fields :${2:child}_mutation",
      "  end",
      "",
      "  def context(ctx) do",
      "      loader =",
      "          Dataloader.new()",
      "          |> Dataloader.add_source(",
      "              :data,",
      "              Dataloader.Ecto.new(${3:repo_module}.Repo, query: &my_data/2)",
      "          )",
      "",
      "      Map.put(ctx, :loader, loader)",
      "  end",
      "",
      "  def plugins do",
      "      [Absinthe.Middleware.Dataloader] ++ Absinthe.Plugin.defaults()",
      "  end",
      "",
      "  def my_data(queryable, _params) do",
      "      queryable",
      "  end",
      "end"
    ],
    "description": "absinthe schema definition"
  },

  "@desc": {
    "prefix": "@desc",
    "body": ["@desc ~S\"\"\"", "  ${1}", "\"\"\""],
    "description": "@desc"
  },

  "helperfunction": {
    "prefix": "helperfunction",
    "body": [
      "############################################",
      "# START ${1}",
      "############################################",
      "",
      "${2}",
      "",
      "############################################",
      "# END ${1}",
      "############################################"
    ],
    "description": "helperfunction"
  },

  "GenServer snippet": {
    "prefix": ["genserver_snippet", "user_genserver"],
    "body": [
      "defmodule ${1:ModuleName} do",
      "  use GenServer",
      "",
      "  ## Client API",
      "",
      "  def start_link(opts) do",
      "      GenServer.start_link(",
      "        __MODULE__,",
      "        opts.initial_state,",
      "        opts",
      "      )",
      "  end",
      "",
      "  ## GenServer Callbacks",
      "",
      "  @impl true",
      "  def init(state) do",
      "      {:ok, state}",
      "  end",
      "",
      "  @impl true",
      "  def handle_call(:pop, _from, state) do",
      "      {:reply, :ok, state}",
      "  end",
      "",
      "  @impl true",
      "  def handle_cast(:push, state) do",
      "      {:noreply, state}",
      "  end",
      "",
      "  @impl true",
      "  def handle_info(:info, state) do",
      "      {:noreply, state}",
      "  end",
      "end"
    ],
    "description": "GenServer snippet"
  },

  "Def child spec": {
    "prefix": ["def_child_spec", "child_spec_def"],
    "body": [
      "def child_spec(${1:_arg}) do",
      "  %{",
      "      id: ${2:__MODULE__},",
      "      start: {",
      "          # The module to call",
      "          ${3:__MODULE__},",
      "          # start_func, conventionally `:start_link`",
      "          ${4::start_link},",
      "          # we will call module.start_func(..start_func_args)",
      "          [${5:start_func_args}]",
      "      },",
      "      # or :supervisor",
      "      type: ${6::worker},",
      "      # Optional - :temporary / :transient",
      "      ${7:restart: :permanent,}",
      "      # Optional: defaults to 5_000 for worker and :infinity for supervisor",
      "      ${8:shutdown: 5_000}",
      "  }",
      "end"
    ],
    "description": "Def child spec"
  },

  "Process get callers": {
    "prefix": ["process_get_callers", "callers_process_get"],
    "body": ["Process.get(:\"\\$callers\")"],
    "description": "Process get callers"
  },

  "if else clause": {
    "prefix": "ifelse",
    "body": [
      "if ${1:condition} do",
      "  ${2:expr}",
      "else",
      "  ${3:expr}",
      "end"
    ],
    "description": "if else clause"
  },

  "if inline": {
    "prefix": ["if_short", "if_inline", "if:"],
    "body": "if ${1:condition}, do: $0",
    "description": "if inline"
  },

  "if else inline": {
    "prefix": ["if_inline_else", "if_short_else"],
    "body": "if ${1:condition}, do: $2, else: $0",
    "description": "if else inline"
  },

  "cond": {
    "prefix": "cond",
    "body": ["cond do", "  $1 -> ", "  $0", "end"]
  },

  "def + doc": {
    "prefix": "defdoc",
    "body": [
      "@doc \"\"\"",
      "${1:doc}",
      "\"\"\"",
      "def ${2:func_name}(${3:args}) do",
      "  $0",
      "end"
    ]
  },

  "def + doc false": {
    "prefix": "defdocfalse",
    "body": ["@doc false", "def ${1:func_name}(${2:arg}) do", "  $0", "end"]
  },

  "def + spec": {
    "prefix": "defspec",
    "body": [
      "@spec ${1:func_name}(${2:args}) :: ${3:no_return}",
      "def $1(${4:args}) do",
      "  $0",
      "end"
    ]
  },

  "def + doc + spec": {
    "prefix": "defdocspec",
    "body": [
      "@doc \"\"\"",
      "${1:doc}",
      "\"\"\"",
      "@spec ${2:func_name}(${3:args}) :: ${4:no_return}",
      "def ${2:func_name}(${5:args}) do",
      "  $0",
      "end"
    ]
  },

  "moduledoc s": {
    "prefix": "mdocs",
    "body": ["@moduledoc ~S\"\"\"", "$0", "\"\"\""]
  },

  "require": {
    "prefix": "req",
    "body": "require ${0:Logger}"
  },

  "test": {
    "prefix": "test",
    "body": ["test ${1:name} do", "  $0", "end"]
  },

  "des": {
    "prefix": "test",
    "body": ["describe \"${1:test group subject}\" do", "  $0", "end"]
  },

  // IEX
  "IEx.pry": {
    "prefix": ["pry_iex", "iex_pry"],
    "body": ["require IEx; IEx.pry$0"],
    "description": "IEx.pry"
  },

  "IEx.configure": {
    "prefix": ["iex_configure", "configure_iex"],
    "body": ["IEx.configure(inspect: [charlists: :as_lists])", "$0"],
    "description": "IEx.configure"
  },
  // END IEX

  "pipe char": {
    "prefix": "p",
    "body": "|> $0"
  },
  "pipe into each": {
    "prefix": ">e",
    "body": "|> Enum.each($0)"
  },
  "pipe into map": {
    "prefix": ">m",
    "body": "|> Enum.map($0)"
  },
  "pipe into filter": {
    "prefix": ">f",
    "body": "|> Enum.filter($0)"
  },
  "pipe into reduce": {
    "prefix": ">f",
    "body": "|> Enum.reduce(${1:acc}, fn ${2}, ${3:acc} -> $0 end)"
  },

  "word list": {
    "prefix": ["word_list", "list_word", "wlw"],
    "body": "~w($0)",
    "description": "Word list"
  },

  "atom list": {
    "prefix": ["atom_list", "list_atom", "wla"],
    "body": "~w($0)a",
    "description": "Atom list"
  },

  "receive after block": {
    "prefix": ["receive_after"],
    "body": [
      "receive do",
      "  ${1:{:message_type, value\\}} ->",
      "      ${2:# code}",
      "after",
      "  ${3:timeout} ->",
      "      ${4:# code}",
      "end"
    ],
    "description": "receive after block"
  },

  "mix test interactive": {
    "prefix": ["mix_test_interactive", "interactive_mix_test"],
    "body": [
      "{:mix_test_interactive, \"~> 1.2\", only: [:dev, :test], runtime: false}",
      "",
      "# if Mix.env() == :dev || Mix.env() == :test do",
      "#   config :mix_test_interactive,",
      "#     clear: true,",
      "#     exclude: [~r/db_migration\\/.*/]",
      "# end"
    ],
    "description": "Mix test interactive"
  },

  "Supervisor strategy one_for_one": {
    "prefix": ["one_for_one_strategy", "strategy_one_for_one"],
    "body": "strategy: :one_for_one",
    "description": "Supervisor strategy one_for_one"
  },

  "Supervisor strategy rest_for_one": {
    "prefix": ["rest_for_one_strategy", "strategy_rest_for_one"],
    "body": "strategy: :rest_for_one",
    "description": "Supervisor strategy rest_for_one"
  },
  "Supervisor strategy one_for_all": {
    "prefix": ["one_for_all_strategy", "strategy_one_for_all"],
    "body": "strategy: :one_for_all",
    "description": "Supervisor strategy one_for_all"
  }
}
