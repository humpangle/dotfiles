{
  "if else clause": {
    "prefix": "ifelse",
    "body": ["if ${1:expr} do", "  ${2:expr}", "else", "  ${3:expr}", "end"],
    "description": "if else clause"
  },

  "print to console": {
    "prefix": "puts",
    "body": [
      "IO.puts(\"\"\"\n\n\n",
      "${1:label}: \n    #{ inspect( ${2:expr} ) }\n\n\n",
      "\"\"\")"
    ],
    "description": "print to console - puts"
  },

  "inspect console": {
    "prefix": "putsinspect",
    "body": [
      "IO.inspect(${1:data}, label: \"\n-----------${1:label}------------\n\")",
      "IO.puts(\"-----------end ${1:label}------------\n\")"
    ],
    "description": "print to console puts inspect"
  },

  "inspect with label": {
    "prefix": "inspectlabel",
    "body": [
      "IO.inspect(${1:data}, label: \"\n-----------${2:label}------------\n\")"
    ],
    "description": "print to console puts inspect"
  },

  "inspect with label in pipe": {
    "prefix": "inspectpipe",
    "body": "|> IO.inspect(label: \"\\n----${1:label}----\\n\")",
    "description": "print to console puts inspect"
  },

  "@opaque type": {
    "prefix": "@opaque",
    "body": "@opaque ${1:t} :: ${2:expr}",
    "description": "@opaque type"
  },

  "@type type": {
    "prefix": "@type",
    "body": "@type ${1:t} :: ${2:type}",
    "description": "@type type"
  },

  "@spec": {
    "prefix": "@spec",
    "body": "@spec ${1:fun_name}(${2:param} :: ${3:type}) :: ${4:return}",
    "description": "function specification"
  },

  "for expression": {
    "prefix": "for_expr",
    "body": [
      "for ${1:member1} <- ${2:list1},",
      "    ${3:member2 <- member1},",
      "    ${4:filter},",
      "    ${5:into: %{}} do",
      "  ${6:return}",
      "end"
    ],
    "description": "for expression"
  },

  "for expression no end": {
    "prefix": "for no end expr",
    "body": [
      "for ${1:member1} <- ${2:list1},",
      "    ${3:member2 <- member1},",
      "    ${4:filter},",
      "    ${5:into: %{}} do:",
      "  ${6:return}"
    ],
    "description": "for expression no end"
  },

  "set up test module": {
    "prefix": "defmodule_test",
    "body": [
      "defmodule ${1:Module.Name}Test do",
      "  use ExUnit.Case, async: ${2:true}",
      "  alias ${1:Module.Name}",
      "\n  test \"${3:test name}\" do",
      "    ${4}",
      "  end",
      "end"
    ],
    "description": "set up test module"
  },

  "@behaviour": {
    "prefix": "@behaviour",
    "body": "@behaviour ",
    "description": "@behaviour"
  },

  "Registry": {
    "prefix": "registry",
    "body": [
      "# Add this to supervision: {Registry, keys: :unique, name: ${1:name}}",
      "def ${2:func_name}(${3:param}) do",
      "  {:via, Registry, {${1:name}, ${3:param}}}",
      "end"
    ],
    "description": "Elixir Registry"
  },

  "@moduledoc": {
    "prefix": "@moduledoc",
    "body": ["@moduledoc ~S\"\"\"", "  $1", "\"\"\""],
    "description": "@moduledoc"
  },

  "@moduledoc false": {
    "prefix": "@moduledoc_false",
    "body": "@moduledoc false",
    "description": "@moduledoc false"
  },

  "@doc": {
    "prefix": "@doc",
    "body": ["@doc ~S\"\"\"", "  $1", "\"\"\""],
    "description": "@doc"
  },

  "@doc false": {
    "prefix": "@doc_false",
    "body": "@doc false",
    "description": "@doc false"
  },

  "Supervisor spec": {
    "prefix": "supervisor_spec",
    "body": [
      "%{",
      "  id: ${1:id}, ",
      "  start: {",
      "    Supervisor, ",
      "    :start_link, ",
      "    [",
      "      ${2:children}, ",
      "      [strategy: :one_for_one, name: ${3:name}]",
      "    ]",
      "  }, ",
      "  restart: :${4:transient}, ",
      "  type: :supervisor",
      "}"
    ],
    "description": "Supervisor specification"
  },

  "DynamicSupervisor spec": {
    "prefix": "supervisor_spec_dynamic",
    "body": [
      "%{",
      "id: ${1:compulsory},",
      "start: {",
      "  DynamicSupervisor, ",
      ":start_link, [[strategy: :one_for_one, name: ${2:compulsory}]]}, ",
      "type: :supervisor",
      "}"
    ],
    "description": "DynamicSupervisor specification"
  },

  "Supervised worker spec": {
    "prefix": [ "supervisor_spec_worker", "child_spec_worker"],
    "body": [
      "%{",
      "id: ${1:compulsory}, ",
      "start: {",
      "__MODULE__, ${2:start_func}, [${3:args}]",
      "}, ",
      "type: :worker",
      "}"
    ],
    "description": "DynamicSupervisor worker child specification"
  },

  "Dynamic Supervisor": {
    "prefix":[ "dynamic_supervisor", "supervisor_dynamic"],
    "body": [
      "defmodule ${1:MySupervisor} do",
      "  use DynamicSupervisor",
      "",
      "  @process_name __MODULE__",
      "$0",
      "  ## Client APIs",
      "",
      "  def start_link(init_arg) do",
      "      DynamicSupervisor.start_link(",
      "          # The module which defines init/1 (in this case, this module)",
      "          __MODULE__,",
      "",
      "          # Argument passed to init/1. If there is no argument, just pass the",
      "          # atom `:ok`",
      "          init_arg,",
      "          # Name registration",
      "          name: @process_name",
      "      )",
      "  end",
      "",
      "  def start_child(foo, bar, baz) do",
      "      # If MyWorker is not using the new child specs, we need to pass a map:",
      "      # spec = %{id: MyWorker, start: {MyWorker, :start_link, [foo, bar, baz]}}",
      "      # This is useful if child worker does not follow the `start_link`",
      "      # convention.",
      "",
      "      spec = {",
      "          MyWorker,",
      "          # Argument passed to child worker's `start_link`. If uses function",
      "          # named other than `start_link`, use a spec map as stated above.",
      "          foo: foo, bar: bar, baz: baz",
      "      }",
      "",
      "      DynamicSupervisor.start_child(",
      "          @process_name,",
      "          spec",
      "      )",
      "  end",
      "",
      "  @doc \"\"\"",
      "      Nice utility method to list all processes under supervision",
      "  \"\"\"",
      "  def list_children do",
      "      # [",
      "      #   %{",
      "      #     id: :undefined, # always `:undefined` for dynamic supervisor",
      "      #     child: PID, # or `:restarting` if about to be restarted",
      "      #     type: :worker, # or :supervisor",
      "      #     modules: [] # as defined in child spec",
      "      #   }",
      "      # ]",
      "      DynamicSupervisor.which_children(@process_name)",
      "  end",
      "",
      "  @doc \"\"\"",
      "      Nice utility method to return number of processes under supervision",
      "  \"\"\"",
      "  def count_children do",
      "      # %{active: 2, specs: 2, supervisors: 0, workers: 2}",
      "      DynamicSupervisor.count_children(@process_name)",
      "  end",
      "",
      "  ## Supervisor callbacks",
      "",
      "  @impl true",
      "  def init(init_arg) do",
      "      DynamicSupervisor.init(",
      "          strategy: :one_for_one,",
      "          extra_arguments: [init_arg]",
      "      )",
      "  end",
      "end",
      "",
      "# Add this supervisor to your main supervision tree:",
      "# children = [",
      "#   {",
      "#     MySupervisor,",
      "#     strategy: :one_for_one, name: MySupervisor",
      "#   }",
      "# ]",
      "#",
      "# Supervisor.start_link(",
      "#   children,",
      "#   strategy: :one_for_one",
      "# )"
    ],
    "description": "Dynamic Supervisor"
  },
  "Create ecto table": {
    "prefix": "create_table_ecto",
    "body": [
      "create table(:${1:table_name}, primary_key: false) do",
      "  add :id, :binary_id, primary_key: true, comment: \"Primary key\"",
      "  add :source, :string, null: false, default: \"password\", comment: \"source of token\"",
      "  add :token, :string, null: false, comment: \"token from source\"",
      "  add :related_id, references(:relateds, on_delete: :delete_all), null: false, comment: \"The owner of ${1:table_name}\"",
      "",
      "  timestamps(type: :utc_datetime)",
      "end",
      "",
      ":${1:table_name}",
      "|> index([:source, :token])",
      "|> create()",
      "",
      ":${1:table_name}",
      "|> unique_index([:related_id, :source])",
      "|> create()"
    ],
    "description": "Create ecto table"
  },

  "Create ecto schema": {
    "prefix": "create_schema_ecto",
    "body": [
      "defmodule ${1:module_name} do",
      "  use Ecto.Schema, warn: true",
      "",
      "  import Ecto.Changeset",
      "",
      "  alias Ecto.Changeset",
      "",
      "  @primary_key {:id, :binary_id, autogenerate: true}",
      "  @foreign_key_type :binary_id",
      "  schema \"${2:schema_name}\" do",
      "    field(:${3:field_name}, :string)",
      "",
      "    timestamps(type: :utc_datetime)",
      "  end",
      "",
      "  @doc \"changeset\"",
      "  def changeset(%__MODULE__{} = ${4:name}, %{} = ${5:attrs}) do",
      "    ${4:name}",
      "    |> cast(${5:attrs}, [:${3:field_name}])",
      "  end",
      "end"
    ],
    "description": "Create ecto schema"
  },

  "Ecto aliases": {
    "prefix": "ecto_aliases",
    "body": [
      "defp aliases do",
      "  [",
      "    \"ecto.setup\": [\"ecto.create\", \"ecto.migrate\", \"run priv/repo/seeds.exs\"],",
      "    \"ecto.reset\": [\"ecto.drop\", \"ecto.setup\"],",
      "    test: [\"ecto.create --quiet\", \"ecto.migrate\", \"test\"]",
      "  ]",
      "end"
    ],
    "description": "Ecto aliases"
  },

  "elixirc_paths": {
    "prefix": "elixirc_paths",
    "body": [
      "# Specifies which paths to compile per environment.",
      "defp elixirc_paths(:dev), do: [\"lib\"${1:, \"another_path\"}]",
      "defp elixirc_paths(:test), do: elixirc_paths(:dev) ++ [\"test/support\"]",
      "defp elixirc_paths(_), do: [\"lib\"]"
    ],
    "description": "elixirc_paths"
  },

  "absinthe child schema": {
    "prefix": "absinthe_child_schema_definition",
    "body": [
      "defmodule ${1:module_parent}.Schema.${2:module_name} do",
      "  use Absinthe.Schema.Notation",
      "",
      "  alias ${1:module_parent}.${2:module_name}.Resolver",
      "",
      "  @desc \"A ${2:module_name}\"",
      "  object :${3:schema_name} do",
      "      field :id, non_null(:id)",
      "",
      "      field :inserted_at, non_null(:iso_datetime)",
      "      field :updated_at, non_null(:iso_datetime)",
      "  end",
      "",
      "  @desc \"Variables for creating ${2:module_name}\"",
      "  input_object :${3:schema_name} do",
      "      field :name, non_null(:string)",
      "  end",
      "",
      "  @desc \"Mutations allowed on ${2:module_name} object\"",
      "  object :${3:schema_name}_mutation do",
      "      @doc \"Create a ${3:schema_name}\"",
      "      field :field_input, :${3:schema_name} do",
      "          arg :field_input, non_null(:field_input)",
      "",
      "          resolve(&Resolver.create/3)",
      "      end",
      "  end",
      "",
      "  @desc \"Queries allowed on ${2:module_name} object\"",
      "  object :${3:schema_name}_query do",
      "      @desc \"query a ${3:schema_name} \"",
      "      field :field, :${3:schema_name} do",
      "          arg :field, non_null(:field_input)",
      "          resolve(&Resolver.field/3)",
      "      end",
      "  end",
      "end"
    ],
    "description": "absinthe child schema definition"
  },

  "absinthe schema": {
    "prefix": "absinthe_schema_definition",
    "body": [
      "defmodule ${1:module_name}.Schema do",
      "  use Absinthe.Schema",
      "",
      "  import_types(Absinthe.Type.Custom)",
      "  import_types(${1:module_name}.Schema.Types)",
      "",
      "",
      "  query do",
      "      import_fields :${2:child}_query",
      "  end",
      "",
      "  mutation do",
      "      import_fields :${2:child}_mutation",
      "  end",
      "",
      "  def context(ctx) do",
      "      loader =",
      "          Dataloader.new()",
      "          |> Dataloader.add_source(",
      "              :data,",
      "              Dataloader.Ecto.new(${3:repo_module}.Repo, query: &my_data/2)",
      "          )",
      "",
      "      Map.put(ctx, :loader, loader)",
      "  end",
      "",
      "  def plugins do",
      "      [Absinthe.Middleware.Dataloader] ++ Absinthe.Plugin.defaults()",
      "  end",
      "",
      "  def my_data(queryable, _params) do",
      "      queryable",
      "  end",
      "end"
    ],
    "description": "absinthe schema definition"
  },

  "@desc": {
    "prefix": "@desc",
    "body": ["@desc ~S\"\"\"", "  ${1}", "\"\"\""],
    "description": "@desc"
  },

  "helperfunction": {
    "prefix": "helperfunction",
    "body": [
      "############################################",
      "# START ${1}",
      "############################################",
      "",
      "${2}",
      "",
      "############################################",
      "# END ${1}",
      "############################################"
    ],
    "description": "helperfunction"
  },

  "GenServer snippet": {
    "prefix": "genserver_snippet",
    "body": [
      "defmodule ${1:ModuleName} do",
      "  use GenServer",
      "",
      "  # inside supervisor",
      "  # children = [{${1:ModuleName}, [${2:_arg_from_supervisor}]}]",
      "",
      "  # override default child_spec provided by GenServer",
      "  @impl true",
      "  def child_spec(${2:_arg_from_supervisor}) do",
      "      %{",
      "          id: __MODULE__,",
      "          start: {",
      "              __MODULE__,",
      "              :start_link,",
      "              [initial_state]",
      "          }",
      "      }",
      "  end",
      "",
      "  def start_link(initial_state) do",
      "      GenServer.start_link(__MODULE__, initial_state, name: __MODULE__)",
      "  end",
      "",
      "  ## Client API",
      "",
      "  ## GenServer Callbacks",
      "",
      "  @impl true",
      "  def init(stack) do",
      "      {:ok, stack}",
      "  end",
      "",
      "  @impl true",
      "  def handle_call(:pop, caller_pid, current_state) do",
      "      send(caller_pid, \"processing....\")",
      "      next_state = current_state",
      "      response_to_caller = :ok",
      "      {:reply, response_to_caller, next_state}",
      "  end",
      "",
      "  @impl true",
      "  def handle_cast({:push, payload}, current_state) do",
      "      next_state = {current_state, payload}",
      "      {:noreply, next_state}",
      "  end",
      "end"
    ],
    "description": "GenServer snippet"
  },
  "if .. do .. end": {
    "prefix": "if",
    "body": ["if ${1:condition} do", "  $0", "end"]
  },
  "if .. do:": {
    "prefix": "if:",
    "body": "if ${1:condition}, do: $0"
  },
  "if .. do .. else .. end": {
    "prefix": "ifelse",
    "body": ["if ${1:condition} do", "  $2", "else", "  $0", "end"]
  },
  "if .. do: .. else:": {
    "prefix": "ife:",
    "body": "if ${1:condition}, do: $2, else: $0"
  },
  "cond": {
    "prefix": "cond",
    "body": ["cond do", "  $1 -> ", "  $0", "end"]
  },
  "case": {
    "prefix": "case",
    "body": ["case $1 do", "  $2 -> ", "    $0", "end"]
  },
  "for": {
    "prefix": "for",
    "body": ["for ${1:item} <- ${2:items} do", "  $0", "end"]
  },

  "def + doc": {
    "prefix": "defdoc",
    "body": [
      "@doc \"\"\"",
      "  ${1:doc}",
      "\"\"\"",
      "def ${2:func_name}(${3:args}) do",
      "  $0",
      "end"
    ]
  },

  "def + doc false": {
    "prefix": "defdocfalse",
    "body": ["@doc false", "def ${1:func_name}(${2:arg}) do", "  $0", "end"]
  },

  "def + spec": {
    "prefix": "defspec",
    "body": [
      "@spec ${1:func_name}(${2:args}) :: ${3:no_return}",
      "def $1(${4:args}) do",
      "  $0",
      "end"
    ]
  },

  "def + doc + spec": {
    "prefix": "defdocspec",
    "body": [
      "@doc \"\"\"",
      "  ${1:doc}",
      "\"\"\"",
      "@spec ${2:func_name}(${3:args}) :: ${4:no_return}",
      "def ${2:func_name}(${5:args}) do",
      "  $0",
      "end"
    ]
  },

  "doc": {
    "prefix": "doc",
    "body": ["@doc \"\"\"", "$0", "\"\"\""]
  },

  "doc s": {
    "prefix": "docs",
    "body": ["@doc ~S\"\"\"", "$0", "\"\"\""]
  },
  "doc false": {
    "prefix": "docf",
    "body": "@doc false"
  },
  "moduledoc": {
    "prefix": "mdoc",
    "body": ["@moduledoc \"\"\"", "$0", "\"\"\""]
  },
  "moduledoc s": {
    "prefix": "mdocs",
    "body": ["@moduledoc ~S\"\"\"", "$0", "\"\"\""]
  },
  "moduledoc false": {
    "prefix": "mdocf",
    "body": "@moduledoc false"
  },
  "require": {
    "prefix": "req",
    "body": "require ${0:Logger}"
  },
  "test": {
    "prefix": "test",
    "body": ["test ${1:name} do", "  $0", "end"]
  },
  "des": {
    "prefix": "test",
    "body": ["describe \"${1:test group subject}\" do", "  $0", "end"]
  },
  "IEx.pry": {
    "prefix": "pry",
    "body": ["require IEx; IEx.pry", "$0"]
  },
  "pipe char": {
    "prefix": "p",
    "body": "|> $0"
  },
  "pipe into each": {
    "prefix": ">e",
    "body": "|> Enum.each($0)"
  },
  "pipe into map": {
    "prefix": ">m",
    "body": "|> Enum.map($0)"
  },
  "pipe into filter": {
    "prefix": ">f",
    "body": "|> Enum.filter($0)"
  },
  "pipe into reduce": {
    "prefix": ">f",
    "body": "|> Enum.reduce(${1:acc}, fn ${2}, ${3:acc} -> $0 end)"
  },
  "word list": {
    "prefix": "wl",
    "body": "~w($0)"
  },
  "atom list": {
    "prefix": "wl",
    "body": "~w($0)a"
  }
}
