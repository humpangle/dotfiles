Hooked on D3: Creating Animated Ch(art)s with D3 and React Hooks - Monica Wojciechowska
=====
https://github.com/monicawoj/hooked-on-d3-animation-deck/blob/master/presentation.mdx

https://github.com/sxywu/react-d3-example/blob/master/src/visualizations/LineChart.js


-------------------------------------------------------------------------------
domain and range and scale
-------------------------------------------------------------------------------
const xScale = scaleLiner().domain(...dataArray).range([min, max])
  domain may also == domain([min_val_of_your_data, max_val_of_your_data])
  range == range([lowest_x_axis_val, highest_x_axis_val])
  or
  range([highest_y_axis_val, lowest_y-axis_val]) -- because svg 0,0 is at top-left corner, but y-axis is from bottom-left corner.

xScale(dataValue) -> screenValue
    maps from your data value to screen value in pixel

xScale.invert(screenValue) -> dataValue
    maps from screenValue to dataValue (e.g. find dataValue from mouse position on screen)

      SETTING DOMAIN AFTER FETCHING DATA
```javascript
import {scaleLiner} from 'd3-scale'
import {max as d3Max, extent as d3Extent} from 'd3-array'
import fetch

const xScale = scaleLiner().range(0, 500);

fetch('url')
  .then(r => r.json())
  .then(data => {
    xScale.domain([0, d3Max(data, d => d.value)]) // [0, 100]
    // or xScale.domain(d3Extent(data, d => d.value)) // d3.extent => [min, max]
    // this implies that every value from your data (domain) will be scaled times 5 when drawn to screen (range).
  })
```


-------------------------------------------------------------------------------
          RECIPE: draw bar chart - category scale on left, quantity scale on top
-------------------------------------------------------------------------------

```javascript
import {axisTop as d3AxisTop, axisLeft as d3AxisLeft} from 'd3-axis'
import {scaleLinear as d3ScaleLinear, scaleBand as d3ScaleBand} from 'd3-scale'

const labels = ['a', 'b', 'c'];

export function setUpD3() {


  const yScaleBand = d3ScaleBand()
                        .range([0, height]) // because 0 is on top
                        .domain(labels);

  const xScaleLinear = d3ScaleLinear()
                        .range([0, width])
                        .domain(0, max_quantity);

  const yAxisLeft = d3AxisLeft(yScaleBand);
  const xAxisTop = d3AxisTop(xScaleLinear);

  return {
    yScaleBand,
    xScaleLinear,
    yAxisLeft,
    xAxisTop,
  }
}

export function computeBars(data, d3Helpers) {
  const {yScaleBand, xScaleLinear, } = d3Helpers;

  const bars = labels.map(label => {
    const d = data[label];

    return {
      y: yScaleBand(label)
      width: xScaleLinear(d), // svg width of bar is along top x-axis
      key: label
    }
  })

  return {bars}
}
```

```svelte
<script>
  import {select as d3Select} from 'd3-selection'
  import {onMount} from 'svelte'
  import {setUpD3, computeBars} from './utils'

  const d3Helpers = setUpD3();

  // remeber: category is on left axis.
  const barHeight = d3Helpers.yScaleBand.bandWidth();

  let xAxisTopRef;
  let yAxisLeftRef;
  let bars = {bars: []}

  onMount(async () => {
    const data = await fetchData();
    bars = computeBars(data, d3Helpers)
  })

  $: if(bars.bars.length > 0) {
    const {xAxisTop, yAxisLeft} = d3Helpers;

    d3Select(xAxisTopRef)(xAxisTop);
    d3Select(yAxisLeftRef)(yAxisLeft);
  }
</script>

<svg width="600" height="500">

  <g bind:this={xAxisTopRef} />
  <g bind:this={yAxisLeftRef} />

  <g class="bar-container" transform="translate({marginLeft},{marginTop})">
    {#each bars.bars as bar (bar.key) }
      <rect
        class="bar"
        x="0"
        y="{bar.y}"
        width={bar.width}
        height={barHeight}
        fill="blue"
      />
    {/each}
  </g>

</svg>
```

-------------------------------------------------------------------------------
                                            clamping
-------------------------------------------------------------------------------

if clamping is not specified, dataValue not in the domain given to scale (scale = scaleLinear()..) will produce screenValue not in the range and vice versa for invert

const x = d3.scaleLinear()
    .domain([10, 130])
    .range([0, 960]);

no clamping
==========

x(-10); // -160, outside range
x.invert(-160); // -10, outside domain

with clamping
=============
x.clamp(true);
x(-10); // 0, clamped to range
x.invert(-160); // 10, clamped to domain

-------------------------------------------------------------------------------
        lines line shape
-------------------------------------------------------------------------------
import {line} from 'd3-shape'

const lineGenFn = line()
lineGenFn.x((current_data, index, all_data_array) => xScale(current_data.attribute_for_x))
    // generates x coordinates

lineGenFn.x((current_data, index, all_data_array) => yScale(current_data.attribute_for_y))
    // generates y coordinates

const linePath = lineGenFn(all_data_array)
<path d={linePath} fill="none" stroke-width="2" />

-------------------------------------------------------------------------------
        axes axis
-------------------------------------------------------------------------------

import { axisBottom as d3AxisBottom, axisLeft as d3AxisLeft } from "d3-axis";
import { select as d3Select } from "d3-selection";

const xAxisBottom = d3AxisBottom(xScale).tickFormat(timeFormat("%b"));
const yAxisLeft = d3AxisLeft(yScale).tickFormat(d => `${d}F`);

// the intuition is like xAxisBottom.render(d3Select(xAxisContainerDom))
d3Select(xAxisContainerDom).call(xAxisBottom);
d3Select(yAxisContainerDom).call(yAxisLeft);

-------------------------------------------------------------------------------
        selection select element/elements
-------------------------------------------------------------------------------

const d3SelectedBody = d3.select("body");
    [[domBody, parentNode: htmlElement]]

const d3AppendedDiv = d3SelectedBody.append("div");
d3AppendedDiv.html("Hello, world!");

const d3SelectedAllSections = d3.selectAll("section");
    [
      [
        s1,
        s2,
        s3,
        ...,
        parentNode: htmlElement
      ]
    ]

const d3AppendedSpan = d3SelectedAllSections.append/insert('span')
    [
      [
        spanOfS1, // binded to parent section element data.
        spanOfS2,
        ....,
        spanOfSn,
        parentNode: htmlElement
      ]
    ]


const d3SelectedDivs = d3SelectedAllSections.select("div");
    [
      [
        div1OfS1, // an entry may be null if selection does not exist.
        div1OfS2,
        ...,
        div1OfSn,
        parentNode: htmlElement
      ]
    ]
    each div1OfSn element is binded to data of corresponding section element (cos we used .select. This does not hold true for .selectAll)
    div1OfSn.getAttribute('__data__') === s1.getAttribute('__data__')

const d3SelectedAllDivs = d3SelectedAllSections.selectAll("div");
    [
      [d1, d2, ...., dn, parentNode: s1], // group 1
      [d1, d2, divSomething, ...., dn, parentNode: s2], // group 2
      ...,
      [d1, d2, ...., dn, parentNode: sn], // group n
    ]
    selected elements are not binded to data (hence need for selection.join??)
    to bind the divs to data:

d3SelectedAllDivs
  .data(data, d => d.key)
  .join(
    enter => enter.insert('div'),
    update => update,
    exit => exit
  )

data = [
        [div1Data, div2Data, ...., divNData], // group 1 data
        [div1Data, div2Data, ...., divNData], // group 2 data
        ...,
        [div1Data, div2Data, ...., divNData], // group n data
      ]

                    iteration
d3SelectedAllDivs.each((divNodeElement, indexOfDivWithinItsGroup) => {
  // the iteration index is within the group and not withing the selection.
  // e.g. for divSomething, group index is 2, but selection index is 1
  // `this` refers to the element node (just like jquery)
})
                  BINDING DATA
const d3SelectedP = d3.select('p')
d3SelectedP.datum(2) === document.querySelector('p').setAttribute('__data__',2)
const d3InsertedDiv = d3SelectedP.insert('div')
d3InsertedDiv.datum() === 2 // inserted,appended,selected child inherits parent's data
