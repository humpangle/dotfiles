Ctrl-p then Ctrl-q
	detach from a container without quitting it.

docker pull image_name
	download an image unto my machine

docker ps
	list all running docker containers

docker ps -a
	list all docker containers running or not

docker ps -a -q
	list all docker containers running or not, only IDs

docker start unique_part_of_container_id
	e.g. if container IDs are 97f62d678525  and 98f62d678525, "docker start 97" bcos 97 provides enough uniqueness.
  "docker start 97f62d678525" is better though

--------------------------------------------------------
docker run -i -t image_name comand_to_run [command args]
--------------------------------------------------------

-i
	interractive = run in the foreground = will show logs in your console = run in foreground
-t
	attach a tty (can be used to send to send further commands. without this flag, you will never get a tty e.g. you can run python repl)
image_name
	will be downloaded if not on local machine
comand_to_run
	e.g.
	python
	python --version

docker rm $(docker ps -a -q) 
	delete all docker containers - remove

docker run -it --rm -d --name nodejs1 -v /home/kanmii/projects/docker-learn/src/:/files -w /files -p 8080:3000 node:7.7.4-alpine node app.js

docker stop unique_part_of_container_id

docker rm id [..id]
	remove the docker containers

docker rm -f id [...id]

docker run -v $PWD:/files image_name [command_to_run]
	-v <same as --volume> <map the current working directory on my local machine to /files in my docker container>

docker logs container_name_or_id [-f <follow the logs> ]

docker inspect container_name_or_id

docker build -t nodejs-app . 
	-t
		<tag the built image with the name nodejs-app>
	. <look for Dockerfile in current directory otherwise you will need to provide -f flag and Dockerfile to use

docker build -t nodejs-app -f /apth/to/Dockerfile

docker images # list all docker images on this machine

docker rmi image_name_or_id # remove an image from my machine

docker network ls

docker network prune # removes all networks not used by at least one container

docker tag local_image_name remote_image_name

docker inspect your-container-name | grep -e '"Gateway"'
	get ip of your container

docker restart container_name
	restart a stopped container (use instead of spinning up a new one e.g. to run bash commands)
docker exec -it container_name command_to_run(e.g /bin/bash)
	run command in a running container
docker attach container_name
	attach your stdin and stdout to running container name

differences between image and container
=============================
an image is template
a container is an instance of a template

docker run -it -d <start detached mode = terminal not attached. must use docker attach to connect terminal to it> --rm <remove the images when done. will not show up in "docker ps -a" after container exited - good for prototyping> --name ubuntu_1 <container name> ubuntu <image name> /bin/bash
docker run -it --name ubuntu_2 ubuntu /bin/bash
	--name
		docker should assign the name I gave and not some random name (which it does by default)


Dockerfile
======
FROM node:7.7.4-alpine

WORKDIR /src
COPY src/app.js /src
CMD node app.js


docker compose
=============
docker-compose -f ./docker-learn/docker-compose.yml up [...service_names]
  -f docker-compose-file-to-use
  # if service_name/s not specified, all services in the docker-compose.yml file are started

docker-compose rm -f
	forcibly remove all docker containers started with the docker-compose.yml file

docker-compose build
	rebuilds all the images

docker-compose stop

docker-compose run --rm service_name command_to_run
	run arbitrary command/script
	--rm
		remove the image after exiting
	
