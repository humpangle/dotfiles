#!/bin/bash
# shellcheck disable=1090,2009,2046

# -----------------------------------------------------------------------------
# See also for inspiration:
# https://github.com/nickjj/docker-flask-example/blob/main/run
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Extend the search path so you can easily use executable that are not are the
# normal search path
# -----------------------------------------------------------------------------
PATH=./node_modules/.bin:$PATH

function splitenvs {
  : ""

  if [[ "$1" =~ ^/ ]]; then
    env_file_abs_path="$1"
  else
    env_file_abs_dir="$(
      (cd -- "$(dirname "$1")" || exit) >/dev/null 2>&1
      pwd -P
    )"

    env_file_abs_path="$env_file_abs_dir/$1"
  fi

  new_asbolute_file_path="$env_file_abs_path.n"
  rm -rf "$new_asbolute_file_path"

  declare -A env_key_to_value_map

  line_regex="^[^#]+.+"

  # shellcheck disable=2013
  while read -r line; do
    if [[ "$line" =~ $line_regex ]]; then
      key=$(echo "$line" | cut -d '=' -f 1)
      val=$(echo "$line" | cut -d'=' -f 2-)

      for line_with_varirables in $(echo "$val" | grep -Po '\$\{\K.+?(?=\})'); do
        variable_text="\${$line_with_varirables}"
        variable_val="${env_key_to_value_map[$line_with_varirables]}"

        if [[ -z "$variable_val" ]]; then
          variable_val=${!line_with_varirables}
        fi

        val="${val//$variable_text/$variable_val}"
      done

      env_key_to_value_map["$key"]="${val}"
    fi
  done <<<$(cat "$env_file_abs_path")

  is_file=1
  text=

  if [[ -n "$2" ]]; then
    is_file=
    text=""
  fi

  for key in "${!env_key_to_value_map[@]}"; do
    out="$key=${env_key_to_value_map[$key]}"

    if [[ "$is_file" ]]; then
      echo "$out" >>"$new_asbolute_file_path"
    else
      text="$out $text"
    fi
  done

  if [[ "$is_file" ]]; then
    sort "$new_asbolute_file_path" -o "$new_asbolute_file_path"
  else
    echo "$text"
  fi
}

# -----------------------------------------------------------------------------
# Helper functions start with _ and aren't listed in this script's help menu.
# -----------------------------------------------------------------------------

function _helper_function {
  local env
  local splitted_envs=""

  if [[ -n "$1" ]]; then
    env="$1"
  elif [[ -e .env ]]; then
    env=".env"
  fi

  if [[ -n "$env" ]]; then
    set -a
    . $env
    set +a

    splitted_envs=$(splitenvs "$env" --lines)
  fi

  printf "%s" "$splitted_envs"
}

function _wait_until {
  command="${1}"
  timeout="${2:-30}"

  echo -e "\n\n\n=Running: $command=\n\n"

  i=0
  until eval "${command}"; do
    ((i++))

    if [ "${i}" -gt "${timeout}" ]; then
      echo -e "\n\n\n=Command: $command="
      echo -e "failed, aborting due to ${timeout}s timeout!\n\n"
      exit 1
    fi

    sleep 1
  done

  echo -e "\n\n\n= Done successfully running: $command =\n\n"
}

function _timestamp {
  date +'%s'
}

function _raise_on_no_env_file {
  if [[ -n "$SOME_ENV_EXISTS" ]]; then
    if [[ "$SOME_ENV_EXISTS" =~ .env.example ]]; then
      printf "\nERROR: env filename can not be .env.example.\n\n"
      exit 1
    fi

    return 0
  fi

  if [[ -z "$1" ]] || [[ ! -e "$1" ]]; then
    printf "\nERROR:env filename has not been provided or invalid.\n"
    printf "You may also source your environment file.\n\n"
    exit 1
  fi
}

function _has_internet {
  if ping -q -c 1 -W 1 8.8.8.8 >/dev/null; then
    printf 0
  fi

  printf 1
}

function build {
  : "Build the project"
  echo "build task not implemented"
}

function default {
  : "Run a default task"
  build
}

function help {
  : "List available tasks."
  : "They can span multiple lines if needed"
  compgen -A function | grep -v "^_" | while read -r name; do
    paste <(printf '%s' "$name") <(type "$name" | sed -nEe 's/^[[:space:]]*: ?"(.*)";/    \1/p')
  done

  printf "\n"
}

TIMEFORMAT=$'\n\n\nTask completed in %3lR\n'
time "${@:-default}"
