{
  "bash": {
    "prefix": [
      "bash",
      "#!",
      "shebang"
    ],
    "body": [
      "#!/usr/bin/env bash",
      "# shellcheck disable="
    ],
    "description": [
      "Option 1:\n",
      "#!/bin/bash\n",
      "Description: Shebang Bash executor.\n",
      "Option 2:\n",
      "#!/usr/bin/env bash\n",
      "Description: Shell searches for the first match of bash in the $PATH environment variable.\n",
      "It can be useful if you aren't aware of the absolute path or don't want to search for it.\n"
    ]
  },
  "echo": {
    "prefix": "echo",
    "body": "echo \"${0:message}\"",
    "description": "Echo a message."
  },
  "read": {
    "prefix": "read",
    "body": "read -r ${0:VAR}",
    "description": "Read input of ${VAR}."
  },
  "if": {
    "prefix": "if",
    "body": "if [[ ${0:condition} ]]; then\n\t${1}\nfi",
    "description": "An IF statement."
  },
  "elseif": {
    "prefix": "elseif",
    "body": "elif [[ ${0:condition} ]]; then\n\t${1}",
    "description": "Add an elseif to an if statement."
  },
  "else": {
    "prefix": "else",
    "body": "else\n\t${0:command}",
    "description": "else"
  },
  "for_in": {
    "prefix": "forin",
    "body": [
      "for ${1:VAR} in $${2:LIST}; do",
      "  echo \"$${1:VAR}\" ",
      "done"
    ],
    "description": "for loop in list"
  },
  "for_i": {
    "prefix": "fori",
    "body": "for ((${0:i} = 0; ${0:i} < ${1:10}; ${0:i}++)); do\n\techo \"$${0:i}\"\ndone\n",
    "description": "An index-based iteration for loop."
  },
  "while": {
    "prefix": "while",
    "body": "while [[ ${1:condition} ]]; do\n\t${0}\ndone\n",
    "description": "A while loop by condition."
  },
  "until": {
    "prefix": "until",
    "body": "until [[ ${1:condition} ]]; do\n\t${0}\ndone\n",
    "description": "until loop by condition"
  },
  "function": {
    "prefix": "function",
    "body": "${1:name} ()\n{\n\t${0}\n}",
    "description": [
      "This defines a function named name.\n",
      "The reserved word function is optional.\n",
      "If the function reserved word is supplied, the parentheses are optional.\n",
      "1. Recommended way:\n",
      "name() {}\n",
      "2. C-like-way:\nfunction name [()] {}"
    ]
  },
  "case": {
    "prefix": "case",
    "body": "case \"$${0:VAR}\" in\n\t${1:1}) echo 1\n\t;;\n\t${2:2|3}) echo 2 or 3\n\t;;\n\t*) echo default\n\t;;\nesac\n",
    "description": [
      "case word in [ [(] pattern [ | pattern ] ... ) list ;; ] ... esac\n",
      "A case command first expands word, and tries to match it against each pattern in turn."
    ]
  },
  "break": {
    "prefix": "break",
    "body": "break ${0}",
    "description": [
      "The break command tells Bash to leave the loop straight away.\n",
      "Enter the break or break (n) where n=number of loops."
    ]
  },
  "expr": {
    "prefix": "expr",
    "body": "expr ${0:1 + 1}",
    "description": "Calculate numbers with Bash."
  },
  "shellcheck disable": {
    "prefix": [
      "shellcheck_disable",
      "disable_shellcheck",
      "ignore_shellcheck",
      "shellcheck_ignore"
    ],
    "body": [
      "# shellcheck disable=${0:code}"
    ],
    "description": "Shellcheck disable"
  },
  "shellcheck source": {
    "prefix": [
      "shellcheck_source_dev_null",
      "source_shellcheck_dev_null"
    ],
    "body": [
      "# shellcheck source=${0:/dev/null}"
    ],
    "description": "Shellcheck source"
  },
  "helper func": {
    "prefix": [
      "helper_func_comment",
      "helper_func_divider",
      "comment_helper_func",
      "comment_start_end",
      "comment_end_start"
    ],
    "body": [
      "",
      "# -----------------------------------------------------------------------------",
      "# ${1}",
      "# -----------------------------------------------------------------------------",
      "${2}",
      "# -----------------------------------------------------------------------------",
      "# /END/ ${1}",
      "# -----------------------------------------------------------------------------",
      ""
    ],
    "description": "Helper function"
  },
  "raise on no env": {
    "prefix": [
      "raise_on_no_env_file",
      "env_file_raise"
    ],
    "body": [
      "_raise_on_no_env() {",
      "  if [[ ! -e \"\\${ENV_FILENAME}\" ]] ||",
      "      [[ \"\\${ENV_FILENAME}\" =~ .env.example ]]; then",
      "      echo -e \"Environment file does not exist or it's the wrong one.\"",
      "      exit 1",
      "  fi",
      "",
      "  local _required_envs=(",
      "      PROJECT_TAG",
      "      COMPOSE_PROJECT_NAME",
      "      CONTAINER_OPEN_WEB_UI_NAME",
      "      CONTAINER_OPEN_WEB_UI_MAP_VOLUME_DATA",
      "      CONTAINER_OPEN_WEB_UI_PUBLISH_PORT",
      "      CONTAINER_OPEN_WEB_UI_RESTART_VALUE",
      "  )",
      "",
      "  for _env_name in \"\\${_required_envs[@]}\"; do",
      "      printf -v _env_val \"%q\" \"\\${!_env_name}\"",
      "",
      "      if [ \"\\$_env_val\" == \"''\" ]; then",
      "          echo -e \"'\\$_env_name' environment variable is missing\"",
      "          exit 1",
      "      fi",
      "  done",
      "}"
    ],
    "description": [
      "Raise on no env file"
    ]
  },
  "browser sync start": {
    "prefix": [
      "browser_sync_start",
      "start_browser_sync"
    ],
    "body": [
      "browser-sync start \\",
      "  --port \"browser-sync-port\" \\",
      "  --no-ui --no-open --no-notify \\",
      "  --proxy \"localhost:server_port\" \\",
      "  --files src/**/** \\",
      "  --files views/**/** \\",
      "  --files public/**/** &",
      "",
      "echo -n \"\\$!\" >./.___pid/browser-sync"
    ],
    "description": [
      "Browser sync start"
    ]
  },
  "getopt parse options": {
    "prefix": [
      "getopt_parse_options",
      "parse_options_getopt",
      "parse_arguments",
      "argument_parse"
    ],
    "body": [
      "# --------------------------------------------------------------------------",
      "# PARSE ARGUMENTS",
      "# --------------------------------------------------------------------------",
      "local _parsed",
      "local $0_debug",
      "local _timeout",
      "",
      "if ! _parsed=\"\\$(",
      "  getopt \\",
      "      --longoptions=help,debug,timeout: \\",
      "      --options=h,d,t: \\",
      "      --name \"\\$0\" \\",
      "      -- \"\\$@\"",
      ")\"; then",
      "  ${1:___func_help}",
      "  return 129",
      "fi",
      "",
      "# provides proper quoting.",
      "eval set -- \"\\$_parsed\"",
      "",
      "while true; do",
      "  case \"\\$1\" in",
      "    --help | -h)",
      "        ${1:___func_help}",
      "        return",
      "        ;;",
      "",
      "    --debug | -d)",
      "        _debug=1",
      "        shift",
      "        ;;",
      "",
      "    --timeout | -t)",
      "        _timeout=\\$2",
      "        shift 2",
      "        ;;",
      "",
      "    --)",
      "        shift",
      "        break",
      "        ;;",
      "",
      "    *)",
      "        echo \"unknown option \\${1}.\"",
      "        ${1:___func_help}",
      "        return 129",
      "        ;;",
      "  esac",
      "done",
      "",
      "# handle non-option arguments",
      "if [[ \\$# -ne 1 ]]; then",
      "  echo \"\\$0: non optional argument xx is required.\"",
      "  ${1:___func_help}",
      "  return 129",
      "fi",
      "",
      "local _non_optional=\\$1",
      "# --------------------------------------------------------------------------",
      "# end parse arguments",
      "# --------------------------------------------------------------------------"
    ],
    "description": [
      "getopt parse options"
    ]
  },
  "define helper function": {
    "prefix": [
      "def_help_fun",
      "help_fun_def"
    ],
    "body": [
      "___${1:name}_help() {",
      "  : \"___help___ ___$1_help\"",
      "  read -r -d '' var <<'eof' || true",
      "${0:what does function do}. Usage:",
      "  ${2:func} [OPTIONS]",
      "",
      "Options:",
      "  -h,--help",
      "    Print this help text and quit.",
      "",
      "Examples:",
      "  # Get help.",
      "  ${2:func} --help",
      "  ${2:func} -h",
      "",
      "  # Explanation of example.",
      "  ${2:func}",
      "eof",
      "",
      "  echo -e \"\\${var}\"",
      "}"
    ],
    "description": [
      "define helper function"
    ]
  },
  "define alias function": {
    "prefix": [
      "def_alias_func",
      "alias_func_def"
    ],
    "body": [
      "function ${1:alias_name} {",
      "  : \"___alias___ ${2:main_func_name}\"",
      "    $2 \"\\${@}\"",
      "}"
    ],
    "description": [
      "define alias function"
    ]
  },
  "Run.sh task template": {
    "prefix": [
      "task_template",
      "run_sh_template"
    ],
    "body": [
      "#!/usr/bin/env bash",
      "# shellcheck disable=",
      "",
      "set -o errexit",
      "set -o pipefail",
      "set -o noclobber",
      "",
      "# Extend the search path so you can easily use executables that are not on the normal search path.",
      "# PATH=./node_modules/.bin:\\$PATH",
      "",
      "# -----------------------------------------------------------------------------",
      "# Helper functions start with _ and aren't listed in this script's help menu unless you pass an argument to the help",
      "# command.",
      "# -----------------------------------------------------------------------------",
      "",
      "____wait_until_help() {",
      "  read -r -d '' var <<'eof' || true",
      "Run 'command_to_run' and try until 'timeout' is reached. Usage:",
      "  _wait_until [OPTIONS] command_to_run",
      "",
      "Options:",
      "  -h,--help",
      "    Print this help text and quit.",
      "  -s,--sleep",
      "    How long (in seconds) to wait before command is tried again when it fails. Defaults to 1 second.",
      "  -n,--no-exit",
      "    If true, we do not exit when timeout is reached but return. This is great for situations where we do not want",
      "    the script to exit if '_wait_until' does not run successfully.",
      "  -t,--timeout",
      "    How many retries before exiting/returning. Defaults to 30.",
      "  -q,--quiet",
      "    Do not print anything.",
      "",
      "",
      "Examples:",
      "  # Get help.",
      "  _wait_until --help",
      "",
      "  _wait_until \"echo 'something'\"",
      "  _wait_until \"echo something\" --sleep 1 --timeout 2 --no-exit --quiet",
      "  _wait_until command_to_run -s 1 -t 2 -n -q",
      "eof",
      "",
      "  echo -e \"\\${var}\"",
      "}",
      "",
      "_wait_until() {",
      "  : \"___help___ ____wait_until_help\"",
      "",
      "  local _command",
      "  local _timeout=30",
      "  local _sleep=1",
      "  local _no_exit",
      "  local _quiet",
      "",
      "  # --------------------------------------------------------------------------",
      "  # PARSE ARGUMENTS",
      "  # --------------------------------------------------------------------------",
      "  local _parsed",
      "",
      "  if ! _parsed=\"\\$(",
      "      getopt \\",
      "          --longoptions=help,timeout:,sleep:,no-exit,quiet \\",
      "          --options=h,t:,s:,n,q \\",
      "          --name \"\\$0\" \\",
      "          -- \"\\$@\"",
      "  )\"; then",
      "      ____wait_until_help",
      "      exit 1",
      "  fi",
      "",
      "  # Provides proper quoting",
      "  eval set -- \"\\$_parsed\"",
      "",
      "  while true; do",
      "      case \"\\$1\" in",
      "      --help | -h)",
      "          ____wait_until_help",
      "          return",
      "          ;;",
      "",
      "      --timeout | -t)",
      "          _timeout=\"\\$2\"",
      "          shift 2",
      "          ;;",
      "",
      "      --sleep | -s)",
      "          _sleep=\"\\$2\"",
      "          shift 2",
      "          ;;",
      "",
      "      --no-exit | -n)",
      "          _no_exit=1",
      "          shift",
      "          ;;",
      "",
      "      --quiet | -q)",
      "          _quiet=1",
      "          shift",
      "          ;;",
      "",
      "      --)",
      "          shift",
      "          break",
      "          ;;",
      "",
      "      *)",
      "          if [[ -z \"\\$_quiet\" ]]; then",
      "              echo \"Unknown option \\$1.\"",
      "              ____wait_until_help",
      "          fi",
      "",
      "          exit 1",
      "          ;;",
      "      esac",
      "  done",
      "",
      "  # handle non-option arguments",
      "  if [[ \\$# -ne 1 ]]; then",
      "      if [[ -z \"\\$_quiet\" ]]; then",
      "          echo \"\\$0: Non optional argument \\\"command\\\" is required.\"",
      "          ____wait_until_help",
      "      fi",
      "",
      "      exit 1",
      "  fi",
      "",
      "  _command=\\$1",
      "  # --------------------------------------------------------------------------",
      "  # /END/ PARSE ARGUMENTS",
      "  # --------------------------------------------------------------------------",
      "",
      "  if [[ -z \"\\$_quiet\" ]]; then",
      "      _echo \"Running: \\$_command\"",
      "  fi",
      "",
      "  i=0",
      "  until eval \"\\$_command\"; do",
      "      ((i++))",
      "",
      "      if [ \"\\${i}\" -gt \"\\$_timeout\" ]; then",
      "          if [[ -z \"\\$_quiet\" ]]; then",
      "              echo -e \"\\nFailed due to \\${_timeout}(s) timeout. Aborting!\"",
      "          fi",
      "",
      "          if [[ -n \"\\$_no_exit\" ]]; then",
      "              return 0",
      "          else",
      "              return 1",
      "          fi",
      "      fi",
      "",
      "      if [[ -z \"\\$_quiet\" ]]; then",
      "          echo \"Command '\\$_command' failed. Retrying!\"",
      "      fi",
      "",
      "      sleep \"\\$_sleep\"",
      "  done",
      "",
      "  if [[ -z \"\\$_quiet\" ]]; then",
      "      _echo \"Done successfully running: \\$_command\"",
      "  fi",
      "}",
      "",
      "_raise_on_no_env() {",
      "  if [[ ! -e \"\\${ENV_FILENAME}\" ]] ||",
      "      [[ \"\\${ENV_FILENAME}\" =~ .env.example ]]; then",
      "      echo -e \"Environment file does not exist or it's the wrong one.\"",
      "      exit 1",
      "  fi",
      "",
      "  local _required_envs=(",
      "      PROJECT_TAG",
      "      COMPOSE_PROJECT_NAME",
      "  )",
      "",
      "  for _env_name in \"\\${_required_envs[@]}\"; do",
      "      printf -v _env_val \"%q\" \"\\${!_env_name}\"",
      "",
      "      if [ \"\\$_env_val\" == \"''\" ]; then",
      "          echo -e \"'\\$_env_name' environment variable is missing\"",
      "          exit 1",
      "      fi",
      "  done",
      "}",
      "",
      "_has_internet() {",
      "  ping -q -c 1 -W 1 8.8.8.8 >/dev/null",
      "}",
      "",
      "full_line_len=\\$(tput cols)",
      "",
      "_echo() {",
      "  local text=\"\\${*}\"",
      "  local equal='*'",
      "",
      "  local len=\"\\${#text}\"",
      "  len=\\$((full_line_len - len))",
      "  local half=\\$((len / 2 - 1))",
      "",
      "  local line=''",
      "",
      "  for _ in \\$(seq \\$half); do",
      "      line=\"\\${line}\\${equal}\"",
      "  done",
      "",
      "  echo -e \"\\n\\${text}  \\${line}\\${line}\\n\"",
      "}",
      "",
      "# -----------------------------------------------------------------------------",
      "# /END/ HELPER FUNCTIONS",
      "# -----------------------------------------------------------------------------",
      "",
      "___serve_help() {",
      "  read -r -d '' var <<'eof' || true",
      "Start development server. Usage:",
      "  serve",
      "eof",
      "",
      "  echo -e \"\\${var}\"",
      "}",
      "",
      "serve() {",
      "  : \"___help___ ___serve_help\"",
      "",
      "  echo \"serve command not implemented\"",
      "}",
      "",
      "ls_ports() {",
      "  : \"List ports in use\"",
      "",
      "  local _port_regex=\"^[^#]*PORT.*=[^\\$]+\"",
      "  local ignored_ports='587 443 465 80 5432'",
      "  local _ignored_files='.env.example'",
      "",
      "  local _all_ports_in_all_files=()",
      "  local _ports_in_file=()",
      "",
      "  local _old_ifs=\"\\$IFS\"",
      "  local _env_file_pattern",
      "",
      "  for _dir in ./../*; do",
      "      declare -A _port_to_env_keys_map_for_file=()",
      "",
      "      while IFS= read -r -d '' _filename; do",
      "          _env_file_pattern=\"\\$(basename \"\\${_filename}\")\"",
      "",
      "          # shellcheck disable=SC2076",
      "          if [[ \"\\$_ignored_files\" =~ \"\\${_env_file_pattern}\" ]] ||",
      "              echo \"\\$_env_file_pattern\" | grep -P \"\\.resolved\\$\" &>/dev/null; then",
      "              continue",
      "          fi",
      "",
      "          _port_to_env_keys_map_for_file=()",
      "",
      "          while read -r _line; do",
      "              local _port",
      "              local _key",
      "",
      "              if [[ \"\\$_line\" =~ \\$_port_regex ]]; then",
      "                  _key=\"\\$(echo \"\\$_line\" | cut -d'=' -f 1)\"",
      "                  _port=\"\\$(echo \"\\$_line\" | cut -d'=' -f 2-)\"",
      "",
      "                  # shellcheck disable=SC2076",
      "                  if [[ \"\\${ignored_ports}\" =~ \"\\${_port}\" ]]; then",
      "                      continue",
      "                  fi",
      "",
      "                  _all_ports_in_all_files+=(\"\\$_port\")",
      "                  _ports_in_file+=(\"\\$_port\")",
      "",
      "                  _ports_value=\"\\${_port_to_env_keys_map_for_file[\\$_port]}\"",
      "",
      "                  _port_to_env_keys_map_for_file[\"\\${_port}\"]=\"\\${_ports_value} \\${_key}\"",
      "              fi",
      "          done <<<\"\\$(cat \"\\$_filename\")\"",
      "",
      "          if [[ -z \"\\${_ports_in_file[*]}\" ]]; then",
      "              continue",
      "          fi",
      "",
      "          # shellcheck disable=2207",
      "          IFS=\\$'\\n' _ports_in_file=(\\$(sort -u <<<\"\\${_ports_in_file[*]}\"))",
      "",
      "          local _string=''",
      "",
      "          for p in \"\\${_ports_in_file[@]}\"; do",
      "              _keys_for_port=\"\\${_port_to_env_keys_map_for_file[\\$p]}\"",
      "",
      "              IFS=\" \" read -r -a _keys_for_port_list <<<\"\\${_keys_for_port}\"",
      "",
      "              for _key_for_port in \"\\${_keys_for_port_list[@]}\"; do",
      "                  _spaces=''",
      "",
      "                  _len_key_for_port=\\${#_key_for_port}",
      "                  _space_len=\\$((45 - _len_key_for_port))",
      "",
      "                  for i in \\$(seq \\$_space_len); do",
      "                      _spaces=\"\\${_spaces} \"",
      "                  done",
      "",
      "                  _string=\"\\${_string}\\${_key_for_port}\\${_spaces}\\${p}\\n\"",
      "              done",
      "          done",
      "",
      "          echo -e \"\\$_filename:\\n\\${_string}\"",
      "",
      "          _ports_in_file=()",
      "      done < <(find \"\\$_dir\" -maxdepth 1 -type f -name \".env*\" -not -name \".env*n\" -print0)",
      "  done",
      "",
      "  # shellcheck disable=2207",
      "  IFS=\\$'\\n' _all_ports_in_all_files=(\\$(sort -u <<<\"\\${_all_ports_in_all_files[*]}\"))",
      "",
      "  IFS=\"\\$_old_ifs\"",
      "",
      "  echo -e \"\\n\\${_all_ports_in_all_files[*]}\\n\"",
      "}"
    ],
    "description": [
      "Run.sh task template"
    ]
  },
  "Dockerfile RUN inline comment": {
    "prefix": [
      "dockerfile_run_inline_comment",
      "inline_comment_dockerfile_run",
      "comment_run_inline_dockerfile"
    ],
    "body": [
      "`#################### ${1:comment}.` ${2:\\\\}$0"
    ],
    "description": [
      "Dockerfile RUN inline comment"
    ]
  },
  "run.sh help": {
    "prefix": [
      "run_sh_help",
      "help_run_sh"
    ],
    "body": [
      "_is_local_function() {",
      "  local _function_name=\"\\$1\"",
      "  local _this_file_content=\"\\$2\"",
      "",
      "  # Function name is not a local function - but perhaps inherited from the shell.",
      "  if ! grep -qP \"^\\$_function_name\\(\\)\\s+\\{\" <<<\"\\$_this_file_content\" &&",
      "      ! grep -qP \"function\\s+\\${_function_name}\\s+{\" <<<\"\\$_this_file_content\"; then",
      "      return 1",
      "  fi",
      "",
      "  return 0",
      "}",
      "",
      "_command_exists() {",
      "  local command_to_test_=\"\\$1\"",
      "  local this_file_content_=\"\"",
      "  this_file_content_=\"\\$(cat \"\\$0\")\"",
      "",
      "  local all_function_names_=()",
      "  mapfile -t all_function_names_ < <(",
      "      compgen -A function",
      "  )",
      "",
      "  local func_name_=\"\"",
      "  for func_name_ in \"\\${all_function_names_[@]}\"; do",
      "      if ! _is_local_function \"\\$func_name_\" \"\\$this_file_content_\"; then",
      "          continue",
      "      fi",
      "",
      "      if [[ \"\\$func_name_\" == \"\\$command_to_test_\" ]]; then",
      "          return 0",
      "      fi",
      "  done",
      "",
      "  return 1",
      "}",
      "",
      "___help_help() {",
      "  local _usage",
      "",
      "  read -r -d '' _usage <<'eom' || :",
      "Get documentation about available commands/functions. Usage:",
      "  script_or_executable help [OPTIONS]",
      "",
      "By default, we return only external functions unless option `i` is passed in which case we return only internal",
      "(helper) functions or option `a` is given which causes us to print both internal and external functions.",
      "",
      "Options:",
      "  -h",
      "    Print this helper information and exit.",
      "  -i",
      "    Return only internal (helper) functions.",
      "  -a",
      "    Return all functions - both internal and external.",
      "  -p",
      "    Prepend prefix i.e. _func_name ----------- to every line so developer can grep the functon name and get all",
      "    documentation strings for that function name. Without this option, caller may only get examples where the functon",
      "    name is referenced.",
      "",
      "Examples:",
      "  # Get help",
      "  script_or_executable help -h",
      "",
      "  # Grep for command/function documentation",
      "  script_or_executable help -p | grep ^func_or_command_name",
      "eom",
      "",
      "  echo -e \"\\$_usage\"",
      "}",
      "",
      "help() {",
      "  : \"___help___ ___help_help\"",
      "  local function_type_=\"external\"",
      "  local include_prefix_=\"\"",
      "",
      "  local opt_=\"\"",
      "  while getopts ':aip' opt_; do",
      "      case \"\\$opt_\" in",
      "      a)",
      "          function_type_='all'",
      "          ;;",
      "",
      "      i)",
      "          function_type_='internal'",
      "          ;;",
      "",
      "      p)",
      "          include_prefix_=1",
      "          ;;",
      "",
      "      *)",
      "          ___help_help",
      "          exit 1",
      "          ;;",
      "      esac",
      "  done",
      "  shift \\$((OPTIND - 1))",
      "",
      "  # Matching pattern examples:",
      "  # `: \"___help___ ___some_func_help\"`",
      "  # `: \"___help___ ____some-func-help\"`",
      "  local _help_func_pattern=\"[_]*___[a-zA-Z][a-zA-Z0-9_-]*[_-]help\"",
      "",
      "  local function_names_=()",
      "",
      "  if [ \"\\$function_type_\" = external ]; then",
      "      # External functions do not start with _.",
      "      mapfile -t function_names_ < <(",
      "          compgen -A function |",
      "              grep -v '^_'",
      "      )",
      "  elif [ \"\\$function_type_\" = internal ]; then",
      "      # Internal helper functions start with _, but not __",
      "      mapfile -t function_names_ < <(",
      "          compgen -A function |",
      "              grep '^_' |",
      "              grep -v '^__' |",
      "              grep -v -E \"\\$_help_func_pattern\"",
      "      )",
      "  elif [ \"\\$function_type_\" = all ]; then",
      "      mapfile -t function_names_ < <(",
      "          compgen -A function |",
      "              grep -v '^__' |",
      "              grep -v -E \"\\$_help_func_pattern\"",
      "      )",
      "  fi",
      "",
      "  local this_file_content_=\"\"",
      "  this_file_content_=\"\\$(cat \"\\$0\")\"",
      "",
      "  local longest_func_name_len_=0",
      "  local func_name_len_=0",
      "  declare -A name_to_len_map_=()",
      "",
      "  local func_name_=\"\"",
      "  for func_name_ in \"\\${function_names_[@]}\"; do",
      "      func_name_len_=\"\\${#func_name_}\"",
      "      name_to_len_map_[\"\\$func_name_\"]=\"\\${func_name_len_}\"",
      "      if [[ \"\\${func_name_len_}\" -gt \"\\${longest_func_name_len_}\" ]]; then",
      "          longest_func_name_len_=\\${func_name_len_}",
      "      fi",
      "  done",
      "",
      "  declare -A all_output_=()",
      "  declare -A _aliases=()",
      "  declare -A name_spaces_map_=()",
      "",
      "  longest_func_name_len_=\\$((longest_func_name_len_ + 10))",
      "",
      "  local output_prefix_=\"\"",
      "",
      "  for func_name_ in \"\\${function_names_[@]}\"; do",
      "      if ! _is_local_function \"\\$func_name_\" \"\\$this_file_content_\"; then",
      "          continue",
      "      fi",
      "",
      "      local spaces_=\"\"",
      "      func_name_len_=\"\\${name_to_len_map_[\\$func_name_]}\"",
      "      func_name_len_=\\$((longest_func_name_len_ - func_name_len_))",
      "",
      "      for _ in \\$(seq \"\\${func_name_len_}\"); do",
      "          spaces_+=\"-\"",
      "      done",
      "",
      "      local function_def_text_=\"\"",
      "      function_def_text_=\"\\$(type \"\\${func_name_}\")\"",
      "",
      "      local alias_name_=\"\"",
      "",
      "      # Matching pattern example:",
      "      # `: \"___alias___ install-elixir\"`",
      "      alias_name_=\"\\$(",
      "          sed -n \\",
      "              's/^ *: *\"___alias___ *\\([a-zA-Z_-][a-zA-Z0-9_-]*\\).*/\\1/p' \\",
      "              <<<\"\\${function_def_text_}\"",
      "      )\"",
      "",
      "      if [[ -n \"\\${alias_name_}\" ]]; then",
      "          _aliases[\"\\${alias_name_}\"]=\"\\${_aliases[\"\\${alias_name_}\"]} \\${func_name_}\"",
      "          continue",
      "      fi",
      "",
      "      local help_func_=\"\"",
      "      help_func_=\"\\$(",
      "          # Given:",
      "          # `: \"___help___ ___some_func_help\"`",
      "          # Then we extract \"___some_func_help\" into variable help_func_",
      "          sed -nE \\",
      "              \"s/^[[:space:]]+:[[:space:]]*\\\"___help___[[:space:]]+([a-zA-Z0-9_-]*).*/\\1/p\" \\",
      "              <<<\"\\${function_def_text_}\"",
      "      )\"",
      "",
      "      # Get the whole function definition text and extract only the documentation",
      "      # part.",
      "      local doc_lines_=()",
      "      if [[ -n \"\\$help_func_\" ]]; then",
      "          # So we have a helper function - we just eval the helper function and split by new lines.",
      "          mapfile -t doc_lines_ < <(",
      "              eval \"\\$help_func_\" 2>/dev/null",
      "          )",
      "      else",
      "          # Function is not using a helper function but documentation texts - so we extract the documentation texts and",
      "          # split by new lines.",
      "          mapfile -t doc_lines_ < <(",
      "              # ^              Assert position at the start of the line",
      "              # [[:space:]]*   Match any whitespace (spaces, tabs) zero or more times",
      "              # :              Match a literal colon",
      "              # [[:space:]]?   Match an optional whitespace",
      "              # \\\"(.*)\\\"       Match a quoted string and capture the content within the quotes (documentation text)",
      "              # ;              Match a semicolon (shell line termination placed there by command: type _func_name)",
      "              #",
      "              # Examples:",
      "              # : \"This is a documentation line\";",
      "              # :\"This is a documentation line\";",
      "              sed -nEe \"s/^[[:space:]]*: ?\\\"(.*)\\\";/\\1/p\" <<<\"\\$function_def_text_\"",
      "          )",
      "      fi",
      "",
      "      local output_=\"\"",
      "      output_prefix_=\"\\$func_name_ \\$spaces_ \"",
      "",
      "      if [[ -n \"\\${doc_lines_[*]}\" ]]; then",
      "          if [ -z \"\\$include_prefix_\" ]; then",
      "              output_+=\"\\${output_prefix_}\\n\"",
      "              output_prefix_=\"\"",
      "          fi",
      "",
      "          for _doc in \"\\${doc_lines_[@]}\"; do",
      "              # _func_name -------------------- List tmux sessions and clients. Usage:",
      "              output_+=\"\\${output_prefix_}\\$_doc\\n\"",
      "          done",
      "      else",
      "          # _func_name -------------------- *************",
      "          output_=\"\\${output_prefix_}*************\\n\"",
      "      fi",
      "",
      "      all_output_[\"\\$func_name_\"]=\"\\$output_\"",
      "      name_spaces_map_[\"\\$func_name_\"]=\"\\$output_prefix_\"",
      "  done",
      "",
      "  for func_name_ in \"\\${!all_output_[@]}\"; do",
      "      output_=\"\\${all_output_[\"\\$func_name_\"]}\"",
      "      echo -e \"\\$output_\"",
      "",
      "      local alias_names_=\"\\${_aliases[\"\\$func_name_\"]}\"",
      "",
      "      if [[ -n \"\\${alias_names_}\" ]]; then",
      "          echo -e \"\\${name_spaces_map_[\"\\$func_name_\"]} ALIASES: \\${alias_names_}\\n\\n\"",
      "      fi",
      "  done",
      "}",
      "",
      "if [ -z \"\\$1\" ]; then",
      "  # default_command \"\\$@\"",
      "  help \"\\$@\"",
      "elif [[ \"\\$1\" == \"help\" ]]; then",
      "  help \"\\${@:2}\"",
      "elif [[ \"\\$1\" == -h* || \"\\$1\" == -i* || \"\\$1\" == -a* || \"\\$1\" == -p* ]]; then",
      "  help \"\\$@\"",
      "elif _command_exists \"\\$1\"; then",
      "  ### USE THIS",
      "  \"\\$@\"",
      "  ### OR THIS",
      "  TIMEFORMAT=\\$'\\n\\nTask completed in %3lR\\n'",
      "  time \"\\$@\"",
      "else",
      "  echo \"Command not found \\\"\\$1\\\". Type \\\"help -a\\\" for available commands.\" >&2",
      "  exit 127",
      "fi"
    ],
    "description": [
      "run.sh help"
    ]
  },
  "_echo": {
    "prefix": [
      "echo_snippet",
      "run_sh_echo"
    ],
    "body": [
      "full_line_len=\\$(tput cols)",
      "",
      "_echo() {",
      "  local text=\"\\${*}\"",
      "  local equal='*'",
      "",
      "  local len=\"\\${#text}\"",
      "  len=\\$((full_line_len - len))",
      "  local half=\\$((len / 2 - 1))",
      "",
      "  local line=''",
      "",
      "  for _ in \\$(seq \\$half); do",
      "      line=\"\\${line}\\${equal}\"",
      "  done",
      "",
      "  echo -e \"\\n\\${text}  \\${line}\\${line}\\n\"",
      "}"
    ],
    "description": [
      "_echo function"
    ]
  },
  "Snippet while loop find list file": {
    "prefix": [
      "while_list_file",
      "list_file_while_loop",
      "find_files_list"
    ],
    "body": [
      "while IFS= read -r -d '' ${7:_file}; do",
      "  ${8:echo \"\\$_file\"}$0",
      "done < <(",
      "  find ${1:_some_dir} \\",
      "    ${2:-maxdepth 1 \\ }",
      "    -type ${3:f} \\",
      "    ${4:-name \"${5:pattern1}\"} \\",
      "    ${6:-not -name \"pattern2\" \\ }",
      "    -print0",
      ")"
    ],
    "description": [
      "Snippet while loop find list file"
    ]
  },
  "Snippet Echo terminal line": {
    "prefix": [
      "echo_line_terminal",
      "echo_terminal_line",
      "line_echo_terminal"
    ],
    "body": [
      "full_line_len=\\$(tput cols)",
      "",
      "_echo() {",
      "  local text=\"\\${*}\"",
      "  local equal='*'",
      "",
      "  local len=\"\\${#text}\"",
      "  len=\\$((full_line_len - len))",
      "  local half=\\$((len / 2 - 1))",
      "",
      "  local line=''",
      "",
      "  for _ in \\$(seq \\$half); do",
      "      line=\"\\${line}\\${equal}\"",
      "  done",
      "",
      "  echo -e \"\\n\\${text}  \\${line}\\${line}\\n\"",
      "}"
    ],
    "description": [
      "Snippet Echo terminal line"
    ]
  },
  "Snippet source test helper file": {
    "prefix": [
      "source_test_helper_file",
      "helper_file_test_source"
    ],
    "body": [
      "# The following variables and functions are declared and set in cp-vim-session-util.bash. Sourcing that script below",
      "# brings them into this script.",
      "",
      "_variable_name= # <- variable",
      "# _function_name <- function",
      "",
      "# shellcheck source=/dev/null",
      "source \"\\$(dirname \"\\$0\")/../scripts-utils/${1:executable}-util.bash\""
    ],
    "description": [
      "Snippet source test helper file"
    ]
  },
  "Snippet sh echo debug": {
    "prefix": [
      "echo_debug",
      "debug_echo"
    ],
    "body": [
      "echo -e \"${1:\\n\\n }${2:var} ${3:description} => \\$${2:var} $0\" "
    ],
    "description": [
      "Snippet echo debug"
    ]
  },
  "Snippet: one equal one": {
    "prefix": [
      "one_equal_one",
      "1_equal_1",
      "if_one_equal_one",
      "if_1_equal_1"
    ],
    "body": [
      "if [[ 1 -eq 1 ]]; then",
      "  ${0:return}",
      "fi"
    ],
    "description": [
      "Snippet: one equal one"
    ]
  }
}
