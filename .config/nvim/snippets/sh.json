{
  "bash": {
    "prefix": [
      "bash",
      "#!",
      "shebang"
    ],
    "body": [
      "#!/usr/bin/env bash",
      "# shellcheck disable=2034,2209,2135,2155"
    ],
    "description": [
      "Option 1:\n",
      "#!/bin/bash\n",
      "Description: Shebang Bash executor.\n",
      "Option 2:\n",
      "#!/usr/bin/env bash\n",
      "Description: Shell scarchs for the first match of bash in the $PATH environment variable.\n",
      "It can be useful if you aren't aware of the absolute path or don't want to search for it.\n"
    ]
  },
  "echo": {
    "prefix": "echo",
    "body": "echo \"${0:message}\"",
    "description": "Echo a message."
  },
  "read": {
    "prefix": "read",
    "body": "read -r ${0:VAR}",
    "description": "Read input of ${VAR}."
  },
  "if": {
    "prefix": "if",
    "body": "if [[ ${0:condition} ]]; then\n\t${1}\nfi",
    "description": "An IF statement."
  },
  "elseif": {
    "prefix": "elseif",
    "body": "elif [[ ${0:condition} ]]; then\n\t${1}",
    "description": "Add an elseif to an if statement."
  },
  "else": {
    "prefix": "else",
    "body": "else\n\t${0:command}",
    "description": "else"
  },
  "for_in": {
    "prefix": "forin",
    "body": [
      "for ${1:VAR} in $${2:LIST}; do",
      "  echo \"$${1:VAR}\" ",
      "done"
    ],
    "description": "for loop in list"
  },
  "for_i": {
    "prefix": "fori",
    "body": "for ((${0:i} = 0; ${0:i} < ${1:10}; ${0:i}++)); do\n\techo \"$${0:i}\"\ndone\n",
    "description": "An index-based iteration for loop."
  },
  "while": {
    "prefix": "while",
    "body": "while [[ ${1:condition} ]]; do\n\t${0}\ndone\n",
    "description": "A while loop by condition."
  },
  "until": {
    "prefix": "until",
    "body": "until [[ ${1:condition} ]]; do\n\t${0}\ndone\n",
    "description": "until loop by condition"
  },
  "function": {
    "prefix": "function",
    "body": "${1:name} ()\n{\n\t${0}\n}",
    "description": [
      "This defines a function named name.\n",
      "The reserved word function is optional.\n",
      "If the function reserved word is supplied, the parentheses are optional.\n",
      "1. Recommended way:\n",
      "name() {}\n",
      "2. C-like-way:\nfunction name [()] {}"
    ]
  },
  "case": {
    "prefix": "case",
    "body": "case \"$${0:VAR}\" in\n\t${1:1}) echo 1\n\t;;\n\t${2:2|3}) echo 2 or 3\n\t;;\n\t*) echo default\n\t;;\nesac\n",
    "description": [
      "case word in [ [(] pattern [ | pattern ] ... ) list ;; ] ... esac\n",
      "A case command first expands word, and tries to match it against each pattern in turn."
    ]
  },
  "break": {
    "prefix": "break",
    "body": "break ${0}",
    "description": [
      "The break command tells Bash to leave the loop straight away.\n",
      "Enter the break or break (n) where n=number of loops."
    ]
  },
  "expr": {
    "prefix": "expr",
    "body": "expr ${0:1 + 1}",
    "description": "Calculate numbers with Bash."
  },
  "shellcheck disable": {
    "prefix": [
      "shellcheck_disable",
      "disable_shellcheck",
      "ignore_shellcheck",
      "shellcheck_ignore"
    ],
    "body": [
      "# shellcheck disable=${0:code}"
    ],
    "description": "Shellcheck disable"
  },
  "shellcheck source": {
    "prefix": [
      "shellcheck_source",
      "source_shellcheck",
      "ignore_shellcheck",
      "shellcheck_ignore"
    ],
    "body": [
      "# shellcheck source=${0:/dev/null}"
    ],
    "description": "Shellcheck source"
  },
  "helper func": {
    "prefix": [
      "helper_func_comment",
      "helper_func_divider"
    ],
    "body": [
      "",
      "# -----------------------------------------------------------------------------",
      "# START ${1}",
      "# -----------------------------------------------------------------------------",
      "",
      "${2}",
      "",
      "# -----------------------------------------------------------------------------",
      "# END ${1}",
      "# -----------------------------------------------------------------------------",
      ""
    ],
    "description": "Helper function"
  },
  "raise on no env": {
    "prefix": [
      "raise_on_no_env_file",
      "env_file_raise"
    ],
    "body": [
      "_raise_on_no_env() {",
      "  if [[ ! -e \"\\${ENV_FILENAME}\" ]] ||",
      "      [[ \"\\${ENV_FILENAME}\" =~ .env.example ]]; then",
      "      echo -e \"Environment file does not exist or it's the wrong one.\"",
      "      exit 1",
      "  fi",
      "",
      "  local _required_envs=(",
      "      PROJECT_TAG",
      "      COMPOSE_PROJECT_NAME",
      "      CONTAINER_OPEN_WEB_UI_NAME",
      "      CONTAINER_OPEN_WEB_UI_MAP_VOLUME_DATA",
      "      CONTAINER_OPEN_WEB_UI_PUBLISH_PORT",
      "      CONTAINER_OPEN_WEB_UI_RESTART_VALUE",
      "  )",
      "",
      "  for _env_name in \"\\${_required_envs[@]}\"; do",
      "      printf -v _env_val \"%q\" \"\\${!_env_name}\"",
      "",
      "      if [ \"\\$_env_val\" == \"''\" ]; then",
      "          echo -e \"'\\$_env_name' environment variable is missing\"",
      "          exit 1",
      "      fi",
      "  done",
      "}"
    ],
    "description": [
      "Raise on no env file"
    ]
  },
  "browser sync start": {
    "prefix": [
      "browser_sync_start",
      "start_browser_sync"
    ],
    "body": [
      "browser-sync start \\",
      "  --port \"browser-sync-port\" \\",
      "  --no-ui --no-open --no-notify \\",
      "  --proxy \"localhost:server_port\" \\",
      "  --files src/**/** \\",
      "  --files views/**/** \\",
      "  --files public/**/** &",
      "",
      "echo -n \"\\$!\" >./.___pid/browser-sync"
    ],
    "description": [
      "Browser sync start"
    ]
  },
  "getopt parse options": {
    "prefix": [
      "getopt_parse_options",
      "parse_options_getopt",
      "parse_arguments",
      "argument_parse"
    ],
    "body": [
      "# --------------------------------------------------------------------------",
      "# PARSE ARGUMENTS",
      "# --------------------------------------------------------------------------",
      "local _parsed",
      "local _debug",
      "local _timeout",
      "",
      "if ! _parsed=\"\\$(",
      "  getopt \\",
      "      --longoptions=help,debug,timeout: \\",
      "      --options=h,d,t: \\",
      "      --name \"\\$0\" \\",
      "      -- \"\\$@\"",
      ")\"; then",
      "  ___func_help",
      "  return 129",
      "fi",
      "",
      "# provides proper quoting.",
      "eval set -- \"\\$_parsed\"",
      "",
      "while true; do",
      "  case \"\\$1\" in",
      "    --help | -h)",
      "        ___func_help",
      "        return",
      "        ;;",
      "",
      "    --debug | -d)",
      "        _debug=1",
      "        shift",
      "        ;;",
      "",
      "    --timeout | -t)",
      "        _timeout=\\$2",
      "        shift 2",
      "        ;;",
      "",
      "    --)",
      "        shift",
      "        break",
      "        ;;",
      "",
      "    *)",
      "        echo \"unknown option \\${1}.\"",
      "        ___func_help",
      "        return 129",
      "        ;;",
      "  esac",
      "done",
      "",
      "# handle non-option arguments",
      "if [[ \\$# -ne 1 ]]; then",
      "  echo \"\\$0: non optional argument xx is required.\"",
      "  ___func_help",
      "  return 129",
      "fi",
      "",
      "local _non_optional=\\$1",
      "# --------------------------------------------------------------------------",
      "# end parse arguments",
      "# --------------------------------------------------------------------------"
    ],
    "description": [
      "getopt parse options"
    ]
  },
  "define helper function": {
    "prefix": [
      "def_help_fun",
      "help_fun_def"
    ],
    "body": [
      "___${1:name}_help() {",
      "  : \"___help___ ___$1_help\"",
      "  read -r -d '' var <<'eof' || true",
      "${0:what does function do}. Usage:",
      "  ${2:func} [OPTIONS]",
      "",
      "Options:",
      "  --help/-h",
      "    Print this help text and quit.",
      "",
      "Examples:",
      "  # Get help.",
      "  ${2:func} --help",
      "",
      "  # Explanation of example.",
      "  ${2:func}",
      "eof",
      "",
      "  echo -e \"\\${var}\\n\"",
      "}"
    ],
    "description": [
      "define helper function"
    ]
  },
  "define alias function": {
    "prefix": [
      "def_alias_func",
      "alias_func_def"
    ],
    "body": [
      "function ${1:alias_name} {",
      "  : \"___alias___ ${2:main_func_name}\"",
      "    $2 \"\\${@}\"",
      "}"
    ],
    "description": [
      "define alias function"
    ]
  },
  "Run.sh task template": {
    "prefix": [
      "task_template",
      "run_sh_template"
    ],
    "body": [
      "#!/usr/bin/env bash",
      "# shellcheck disable=",
      "",
      "set -o errexit",
      "set -o pipefail",
      "set -o noclobber",
      "",
      "# Extend the search path so you can easily use executables that are not on the normal search path.",
      "# PATH=./node_modules/.bin:\\$PATH",
      "",
      "# -----------------------------------------------------------------------------",
      "# Helper functions start with _ and aren't listed in this script's help menu unless you pass an argument to the help",
      "# command.",
      "# -----------------------------------------------------------------------------",
      "",
      "____wait_until_help() {",
      "  read -r -d '' var <<'eof' || true",
      "Run 'command_to_run' and try until 'timeout' is reached. Usage:",
      "  _wait_until [OPTIONS] command_to_run",
      "",
      "Options:",
      "  --help/-h",
      "      Print this help text and quit.",
      "  --sleep/-s.",
      "      How long (in seconds) to wait before command is tried again when it fails. Defaults to 1 second.",
      "  --no-exit/-n.",
      "      If true, we do not exit when timeout is reached but return. This is great for situations where we want do not want",
      "      the script to exit if '_wait_until' does not run successfully.",
      "  --timeout/-t.",
      "      How many retries before exiting/returning. Defaults to 30.",
      "  --quiet/-q",
      "      Do not print anything.",
      "",
      "",
      "Examples:",
      "  # Get help.",
      "  _wait_until --help",
      "",
      "  _wait_until \"echo 'something'\"",
      "  _wait_until \"echo something\" --sleep 1 --timeout 2 --no-exit --quiet",
      "  _wait_until command_to_run -s 1 -t 2 -n -q",
      "eof",
      "",
      "  echo -e \"\\${var}\"",
      "}",
      "",
      "_wait_until() {",
      "  : \"___help___ ____wait_until_help\"",
      "",
      "  local _command",
      "  local _timeout=30",
      "  local _sleep=1",
      "  local _no_exit",
      "  local _quiet",
      "",
      "  # --------------------------------------------------------------------------",
      "  # PARSE ARGUMENTS",
      "  # --------------------------------------------------------------------------",
      "  local _parsed",
      "",
      "  if ! _parsed=\"\\$(",
      "      getopt \\",
      "          --longoptions=help,timeout:,sleep:,no-exit,quiet \\",
      "          --options=h,t:,s:,n,q \\",
      "          --name \"\\$0\" \\",
      "          -- \"\\$@\"",
      "  )\"; then",
      "      ____wait_until_help",
      "      exit 1",
      "  fi",
      "",
      "  # Provides proper quoting",
      "  eval set -- \"\\$_parsed\"",
      "",
      "  while true; do",
      "      case \"\\$1\" in",
      "      --help | -h)",
      "          ____wait_until_help",
      "          return",
      "          ;;",
      "",
      "      --timeout | -t)",
      "          _timeout=\"\\$2\"",
      "          shift 2",
      "          ;;",
      "",
      "      --sleep | -s)",
      "          _sleep=\"\\$2\"",
      "          shift 2",
      "          ;;",
      "",
      "      --no-exit | -n)",
      "          _no_exit=1",
      "          shift",
      "          ;;",
      "",
      "      --quiet | -q)",
      "          _quiet=1",
      "          shift",
      "          ;;",
      "",
      "      --)",
      "          shift",
      "          break",
      "          ;;",
      "",
      "      *)",
      "          if [[ -z \"\\$_quiet\" ]]; then",
      "              echo \"Unknown option \\$1.\"",
      "              ____wait_until_help",
      "          fi",
      "",
      "          exit 1",
      "          ;;",
      "      esac",
      "  done",
      "",
      "  # handle non-option arguments",
      "  if [[ \\$# -ne 1 ]]; then",
      "      if [[ -z \"\\$_quiet\" ]]; then",
      "          echo \"\\$0: Non optional argument \\\"command\\\" is required.\"",
      "          ____wait_until_help",
      "      fi",
      "",
      "      exit 1",
      "  fi",
      "",
      "  _command=\\$1",
      "  # --------------------------------------------------------------------------",
      "  # END PARSE ARGUMENTS",
      "  # --------------------------------------------------------------------------",
      "",
      "  if [[ -z \"\\$_quiet\" ]]; then",
      "      _echo \"Running: \\$_command\"",
      "  fi",
      "",
      "  i=0",
      "  until eval \"\\$_command\"; do",
      "      ((i++))",
      "",
      "      if [ \"\\${i}\" -gt \"\\$_timeout\" ]; then",
      "          if [[ -z \"\\$_quiet\" ]]; then",
      "              echo -e \"\\nFailed due to \\${_timeout}(s) timeout. Aborting!\"",
      "          fi",
      "",
      "          if [[ -n \"\\$_no_exit\" ]]; then",
      "              return 0",
      "          else",
      "              return 1",
      "          fi",
      "      fi",
      "",
      "      if [[ -z \"\\$_quiet\" ]]; then",
      "          echo \"Command '\\$_command' failed. Retrying!\"",
      "      fi",
      "",
      "      sleep \"\\$_sleep\"",
      "  done",
      "",
      "  if [[ -z \"\\$_quiet\" ]]; then",
      "      _echo \"Done successfully running: \\$_command\"",
      "  fi",
      "}",
      "",
      "_raise_on_no_env() {",
      "  if [[ ! -e \"\\${ENV_FILENAME}\" ]] ||",
      "      [[ \"\\${ENV_FILENAME}\" =~ .env.example ]]; then",
      "      echo -e \"Environment file does not exist or it's the wrong one.\"",
      "      exit 1",
      "  fi",
      "",
      "  local _required_envs=(",
      "      PROJECT_TAG",
      "      COMPOSE_PROJECT_NAME",
      "  )",
      "",
      "  for _env_name in \"\\${_required_envs[@]}\"; do",
      "      printf -v _env_val \"%q\" \"\\${!_env_name}\"",
      "",
      "      if [ \"\\$_env_val\" == \"''\" ]; then",
      "          echo -e \"'\\$_env_name' environment variable is missing\"",
      "          exit 1",
      "      fi",
      "  done",
      "}",
      "",
      "_has_internet() {",
      "  ping -q -c 1 -W 1 8.8.8.8 >/dev/null",
      "}",
      "",
      "full_line_len=\\$(tput cols)",
      "",
      "_echo() {",
      "  local text=\"\\${*}\"",
      "  local equal='*'",
      "",
      "  local len=\"\\${#text}\"",
      "  len=\\$((full_line_len - len))",
      "  local half=\\$((len / 2 - 1))",
      "",
      "  local line=''",
      "",
      "  for _ in \\$(seq \\$half); do",
      "      line=\"\\${line}\\${equal}\"",
      "  done",
      "",
      "  echo -e \"\\n\\${text}  \\${line}\\${line}\\n\"",
      "}",
      "",
      "# -----------------------------------------------------------------------------",
      "# END HELPER FUNCTIONS",
      "# -----------------------------------------------------------------------------",
      "",
      "___serve_help() {",
      "  read -r -d '' var <<'eof' || true",
      "Start development server. Usage:",
      "  serve",
      "eof",
      "",
      "  echo -e \"\\${var}\"",
      "}",
      "",
      "serve() {",
      "  : \"___help___ ___serve_help\"",
      "",
      "  echo \"dev task not implemented\"",
      "}",
      "",
      "ls_ports() {",
      "  : \"List ports in use\"",
      "",
      "  local _port_regex=\"^[^#]*PORT.*=[^\\$]+\"",
      "  local ignored_ports='587 443 465 80 5432'",
      "  local _ignored_files='.env.example'",
      "",
      "  local _all_ports_in_all_files=()",
      "  local _ports_in_file=()",
      "",
      "  local _old_ifs=\"\\$IFS\"",
      "  local _env_file_pattern",
      "",
      "  for _dir in ./../*; do",
      "      declare -A _port_to_env_keys_map_for_file=()",
      "",
      "      while IFS= read -r -d '' _filename; do",
      "          _env_file_pattern=\"\\$(basename \"\\${_filename}\")\"",
      "",
      "          # shellcheck disable=SC2076",
      "          if [[ \"\\$_ignored_files\" =~ \"\\${_env_file_pattern}\" ]] ||",
      "              echo \"\\$_env_file_pattern\" | grep -P \"\\.resolved\\$\" &>/dev/null; then",
      "              continue",
      "          fi",
      "",
      "          _port_to_env_keys_map_for_file=()",
      "",
      "          while read -r _line; do",
      "              local _port",
      "              local _key",
      "",
      "              if [[ \"\\$_line\" =~ \\$_port_regex ]]; then",
      "                  _key=\"\\$(echo \"\\$_line\" | cut -d'=' -f 1)\"",
      "                  _port=\"\\$(echo \"\\$_line\" | cut -d'=' -f 2-)\"",
      "",
      "                  # shellcheck disable=SC2076",
      "                  if [[ \"\\${ignored_ports}\" =~ \"\\${_port}\" ]]; then",
      "                      continue",
      "                  fi",
      "",
      "                  _all_ports_in_all_files+=(\"\\$_port\")",
      "                  _ports_in_file+=(\"\\$_port\")",
      "",
      "                  _ports_value=\"\\${_port_to_env_keys_map_for_file[\\$_port]}\"",
      "",
      "                  _port_to_env_keys_map_for_file[\"\\${_port}\"]=\"\\${_ports_value} \\${_key}\"",
      "              fi",
      "          done <<<\"\\$(cat \"\\$_filename\")\"",
      "",
      "          if [[ -z \"\\${_ports_in_file[*]}\" ]]; then",
      "              continue",
      "          fi",
      "",
      "          # shellcheck disable=2207",
      "          IFS=\\$'\\n' _ports_in_file=(\\$(sort -u <<<\"\\${_ports_in_file[*]}\"))",
      "",
      "          local _string=''",
      "",
      "          for p in \"\\${_ports_in_file[@]}\"; do",
      "              _keys_for_port=\"\\${_port_to_env_keys_map_for_file[\\$p]}\"",
      "",
      "              IFS=\" \" read -r -a _keys_for_port_list <<<\"\\${_keys_for_port}\"",
      "",
      "              for _key_for_port in \"\\${_keys_for_port_list[@]}\"; do",
      "                  _spaces=''",
      "",
      "                  _len_key_for_port=\\${#_key_for_port}",
      "                  _space_len=\\$((45 - _len_key_for_port))",
      "",
      "                  for i in \\$(seq \\$_space_len); do",
      "                      _spaces=\"\\${_spaces} \"",
      "                  done",
      "",
      "                  _string=\"\\${_string}\\${_key_for_port}\\${_spaces}\\${p}\\n\"",
      "              done",
      "          done",
      "",
      "          echo -e \"\\$_filename:\\n\\${_string}\"",
      "",
      "          _ports_in_file=()",
      "      done < <(find \"\\$_dir\" -maxdepth 1 -type f -name \".env*\" -not -name \".env*n\" -print0)",
      "  done",
      "",
      "  # shellcheck disable=2207",
      "  IFS=\\$'\\n' _all_ports_in_all_files=(\\$(sort -u <<<\"\\${_all_ports_in_all_files[*]}\"))",
      "",
      "  IFS=\"\\$_old_ifs\"",
      "",
      "  echo -e \"\\n\\${_all_ports_in_all_files[*]}\\n\"",
      "}",
      "",
      "help() {",
      "  : \"List available tasks.\"",
      "",
      "  # Matching pattern examples:",
      "  # `: \"___help___ ___some_func_help\"`",
      "  # `: \"___help___ ____some-func-help\"`",
      "  local _help_func_pattern=\"[_]*___[a-zA-Z][a-zA-Z0-9_-]*[_-]help\"",
      "",
      "  if [[ -z \"\\$1\" ]]; then",
      "      # Regular functions.",
      "      mapfile -t names < <(",
      "          compgen -A function |",
      "              grep -v '^_'",
      "      )",
      "  else",
      "      mapfile -t names < <(",
      "          # Helper functions.",
      "          compgen -A function |",
      "              grep '^_' |",
      "              grep -v -E \"\\$_help_func_pattern\"",
      "      )",
      "  fi",
      "",
      "  local _this_file_content",
      "  _this_file_content=\"\\$(cat \"\\$0\")\"",
      "",
      "  local len=0",
      "  declare -A name_to_len_map=()",
      "",
      "  for name in \"\\${names[@]}\"; do",
      "      _len=\"\\${#name}\"",
      "      name_to_len_map[\"\\$name\"]=\"\\${_len}\"",
      "      if [[ \"\\${_len}\" -gt \"\\${len}\" ]]; then len=\\${_len}; fi",
      "  done",
      "",
      "  declare -A _all_output=()",
      "  declare -A _aliases=()",
      "  declare -A _name_spaces_map=()",
      "",
      "  len=\\$((len + 10))",
      "",
      "  for name in \"\\${names[@]}\"; do",
      "      # Make sure we are only processing function names from this file's content and no names inherited from",
      "      # elsewhere such as the shell.",
      "      if ! grep -qP \"^\\$name\\(\\)\\s+\\{\" <<<\"\\$_this_file_content\" &&",
      "          ! grep -qP \"function\\s+\\${name}\\s+{\" <<<\"\\$_this_file_content\"; then",
      "          continue",
      "      fi",
      "",
      "      local spaces=\"\"",
      "      _len=\"\\${name_to_len_map[\\$name]}\"",
      "      _len=\\$((len - _len))",
      "",
      "      for _ in \\$(seq \"\\${_len}\"); do",
      "          spaces=\"\\${spaces}-\"",
      "          ((++t))",
      "      done",
      "",
      "      local _function_def_text",
      "      _function_def_text=\"\\$(type \"\\${name}\")\"",
      "",
      "      local _alias_name",
      "",
      "      # Matching pattern example:",
      "      # `: \"___alias___ install-elixir\"`",
      "      _alias_name=\"\\$(awk \\",
      "          'match(\\$0, /^ +: *\"___alias___ +([a-zA-Z_-][a-zA-Z0-9_-]*)/, a) {print a[1]}' \\",
      "          <<<\"\\${_function_def_text}\")\"",
      "",
      "      if [[ -n \"\\${_alias_name}\" ]]; then",
      "          _aliases[\"\\${_alias_name}\"]=\"\\${_aliases[\"\\${_alias_name}\"]} \\${name}\"",
      "          continue",
      "      fi",
      "",
      "      local _help_func",
      "",
      "      _help_func=\"\\$(",
      "          awk \\",
      "              -v _awk_help_func_pattern=\"\\$_help_func_pattern\" \\",
      "              'match(\\$0, \"^ +: *\\\"___help___ +(\" _awk_help_func_pattern \")\", a) {print a[1]}' \\",
      "              <<<\"\\$_function_def_text\"",
      "      )\"",
      "",
      "      # Get the whole function definition text and extract only the documentation",
      "      # part.",
      "      if [[ -n \"\\$_help_func\" ]]; then",
      "          mapfile -t _doc_lines < <(",
      "              eval \"\\$_help_func\" 2>/dev/null",
      "          )",
      "      else",
      "          mapfile -t _doc_lines < <(",
      "              sed -nEe \"s/^[[:space:]]*: ?\\\"(.*)\\\";/\\1/p\" <<<\"\\$_function_def_text\"",
      "          )",
      "      fi",
      "",
      "      local _output=\"\"",
      "",
      "      if [[ -n \"\\${_doc_lines[*]}\" ]]; then",
      "          for _doc in \"\\${_doc_lines[@]}\"; do",
      "              _output+=\"\\$name \\$spaces \\$_doc\\n\"",
      "          done",
      "      else",
      "          _output=\"\\$name \\$spaces *************\\n\"",
      "      fi",
      "",
      "      _all_output[\"\\$name\"]=\"\\$_output\"",
      "      _name_spaces_map[\"\\$name\"]=\"\\$name \\$spaces\"",
      "  done",
      "",
      "  for name in \"\\${!_all_output[@]}\"; do",
      "      _output=\"\\${_all_output[\"\\${name}\"]}\"",
      "      echo -e \"\\${_output}\"",
      "",
      "      local _alias_names=\"\\${_aliases[\"\\${name}\"]}\"",
      "",
      "      if [[ -n \"\\${_alias_names}\" ]]; then",
      "          echo -e \"\\${_name_spaces_map[\"\\${name}\"]} ALIASES: \\${_alias_names}\\n\\n\"",
      "      fi",
      "  done",
      "}",
      "",
      "\"\\${@:-help}\"",
      "# TIMEFORMAT=\\$'\\n\\nTask completed in %3lR\\n'",
      "# time \"\\${@:-help}\""
    ],
    "description": [
      "Run.sh task template"
    ]
  },
  "Dockerfile RUN inline comment": {
    "prefix": [
      "dockerfile_run_inline_comment",
      "inline_comment_dockerfile_run",
      "comment_run_inline_dockerfile"
    ],
    "body": [
      "`#################### ${1:comment}.` ${2:\\\\}$0"
    ],
    "description": [
      "Dockerfile RUN inline comment"
    ]
  },
  "run.sh help": {
    "prefix": [
      "run_sh_help",
      "help_run_sh"
    ],
    "body": [
      "help() {",
      "  : \"List available tasks.\"",
      "",
      "  # Matching pattern examples:",
      "  # `: \"___help___ ___some_func_help\"`",
      "  # `: \"___help___ ____some-func-help\"`",
      "  local _help_func_pattern=\"[_]*___[a-zA-Z][a-zA-Z0-9_-]*[_-]help\"",
      "",
      "  if [[ -z \"\\$1\" ]]; then",
      "      # Regular functions do not start with _.",
      "      mapfile -t names < <(",
      "          compgen -A function |",
      "              grep -v '^_'",
      "      )",
      "  else",
      "      # Helper functions start with _.",
      "      mapfile -t names < <(",
      "          compgen -A function |",
      "              grep '^_' |",
      "              grep -v -E \"\\$_help_func_pattern\"",
      "      )",
      "  fi",
      "",
      "  local _this_file_content",
      "  _this_file_content=\"\\$(cat \"\\$0\")\"",
      "",
      "  local len=0",
      "  declare -A name_to_len_map=()",
      "",
      "  for name in \"\\${names[@]}\"; do",
      "      _len=\"\\${#name}\"",
      "      name_to_len_map[\"\\$name\"]=\"\\${_len}\"",
      "      if [[ \"\\${_len}\" -gt \"\\${len}\" ]]; then len=\\${_len}; fi",
      "  done",
      "",
      "  declare -A _all_output=()",
      "  declare -A _aliases=()",
      "  declare -A _name_spaces_map=()",
      "",
      "  len=\\$((len + 10))",
      "",
      "  for name in \"\\${names[@]}\"; do",
      "      # Make sure we are only processing function names from this file's content and no names inherited from",
      "      # elsewhere such as the shell.",
      "      if ! grep -qP \"^\\$name\\(\\)\\s+\\{\" <<<\"\\$_this_file_content\" &&",
      "          ! grep -qP \"function\\s+\\${name}\\s+{\" <<<\"\\$_this_file_content\"; then",
      "          continue",
      "      fi",
      "",
      "      local spaces=\"\"",
      "      _len=\"\\${name_to_len_map[\\$name]}\"",
      "      _len=\\$((len - _len))",
      "",
      "      for _ in \\$(seq \"\\${_len}\"); do",
      "          spaces=\"\\${spaces}-\"",
      "          ((++t))",
      "      done",
      "",
      "      local _function_def_text",
      "      _function_def_text=\"\\$(type \"\\${name}\")\"",
      "",
      "      local _alias_name",
      "",
      "      # Matching pattern example:",
      "      # `: \"___alias___ install-elixir\"`",
      "      _alias_name=\"\\$(awk \\",
      "          'match(\\$0, /^ +: *\"___alias___ +([a-zA-Z_-][a-zA-Z0-9_-]*)/, a) {print a[1]}' \\",
      "          <<<\"\\${_function_def_text}\")\"",
      "",
      "      if [[ -n \"\\${_alias_name}\" ]]; then",
      "          _aliases[\"\\${_alias_name}\"]=\"\\${_aliases[\"\\${_alias_name}\"]} \\${name}\"",
      "          continue",
      "      fi",
      "",
      "      local _help_func",
      "",
      "      _help_func=\"\\$(",
      "          awk \\",
      "              -v _awk_help_func_pattern=\"\\$_help_func_pattern\" \\",
      "              'match(\\$0, \"^ +: *\\\"___help___ +(\" _awk_help_func_pattern \")\", a) {print a[1]}' \\",
      "              <<<\"\\$_function_def_text\"",
      "      )\"",
      "",
      "      # Get the whole function definition text and extract only the documentation",
      "      # part.",
      "      if [[ -n \"\\$_help_func\" ]]; then",
      "          mapfile -t _doc_lines < <(",
      "              eval \"\\$_help_func\" 2>/dev/null",
      "          )",
      "      else",
      "          mapfile -t _doc_lines < <(",
      "              sed -nEe \"s/^[[:space:]]*: ?\\\"(.*)\\\";/\\1/p\" <<<\"\\$_function_def_text\"",
      "          )",
      "      fi",
      "",
      "      local _output=\"\"",
      "",
      "      if [[ -n \"\\${_doc_lines[*]}\" ]]; then",
      "          for _doc in \"\\${_doc_lines[@]}\"; do",
      "              _output+=\"\\$name \\$spaces \\$_doc\\n\"",
      "          done",
      "      else",
      "          _output=\"\\$name \\$spaces *************\\n\"",
      "      fi",
      "",
      "      _all_output[\"\\$name\"]=\"\\$_output\"",
      "      _name_spaces_map[\"\\$name\"]=\"\\$name \\$spaces\"",
      "  done",
      "",
      "  for name in \"\\${!_all_output[@]}\"; do",
      "      _output=\"\\${_all_output[\"\\${name}\"]}\"",
      "      echo -e \"\\${_output}\"",
      "",
      "      local _alias_names=\"\\${_aliases[\"\\${name}\"]}\"",
      "",
      "      if [[ -n \"\\${_alias_names}\" ]]; then",
      "          echo -e \"\\${_name_spaces_map[\"\\${name}\"]} ALIASES: \\${_alias_names}\\n\\n\"",
      "      fi",
      "  done",
      "}",
      "",
      "# if [[ -z \"\\$1\" ]]; then",
      "#   on \"\\$@\"",
      "# elif [[ \"\\$1\" == \"0\" ]] ||",
      "#   [[ \"\\$1\" == \"o\" ]]; then",
      "#   off \"\\${@:2}\"",
      "# elif [[ \"\\$1\" == \"--help\" ]] ||",
      "#   [[ \"\\$1\" == \"-h\" ]]; then",
      "#   help \"\\${@:2}\"",
      "# else",
      "#   \"\\$@\"",
      "# fi",
      "",
      "TIMEFORMAT=\\$'\\n\\nTask completed in %3lR\\n'",
      "time \"\\${@:-help}\""
    ],
    "description": [
      "run.sh help"
    ]
  },
  "_echo": {
    "prefix": [
      "echo_snippet",
      "run_sh_echo"
    ],
    "body": [
      "full_line_len=\\$(tput cols)",
      "",
      "_echo() {",
      "  local text=\"\\${*}\"",
      "  local equal='*'",
      "",
      "  local len=\"\\${#text}\"",
      "  len=\\$((full_line_len - len))",
      "  local half=\\$((len / 2 - 1))",
      "",
      "  local line=''",
      "",
      "  for _ in \\$(seq \\$half); do",
      "      line=\"\\${line}\\${equal}\"",
      "  done",
      "",
      "  echo -e \"\\n\\${text}  \\${line}\\${line}\\n\"",
      "}"
    ],
    "description": [
      "_echo function"
    ]
  }
}
