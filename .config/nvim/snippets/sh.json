{
  "bash": {
    "prefix": ["bash", "#!", "shebang"],
    "body": ["#!/usr/bin/env bash", "# shellcheck disable=2034,2209,2135,2155"],
    "description": [
      "Option 1:\n",
      "#!/bin/bash\n",
      "Description: Shebang Bash executor.\n",
      "Option 2:\n",
      "#!/usr/bin/env bash\n",
      "Description: Shell searchs for the first match of bash in the $PATH environment variable.\n",
      "It can be useful if you aren't aware of the absolute path or don't want to search for it.\n"
    ]
  },
  "echo": {
    "prefix": "echo",
    "body": "echo \"${0:message}\"",
    "description": "Echo a message."
  },
  "read": {
    "prefix": "read",
    "body": "read -r ${0:VAR}",
    "description": "Read input of ${VAR}."
  },
  "if": {
    "prefix": "if",
    "body": "if [[ ${0:condition} ]]; then\n\t${1}\nfi",
    "description": "An IF statement."
  },
  "elseif": {
    "prefix": "elseif",
    "body": "elif [[ ${0:condition} ]]; then\n\t${1}",
    "description": "Add an elseif to an if statement."
  },
  "else": {
    "prefix": "else",
    "body": "else\n\t${0:command}",
    "description": "else"
  },
  "for_in": {
    "prefix": "forin",
    "body": ["for ${1:VAR} in $${2:LIST}; do", "  echo \"$${1:VAR}\" ", "done"],
    "description": "for loop in list"
  },
  "for_i": {
    "prefix": "fori",
    "body": "for ((${0:i} = 0; ${0:i} < ${1:10}; ${0:i}++)); do\n\techo \"$${0:i}\"\ndone\n",
    "description": "An index-based iteration for loop."
  },
  "while": {
    "prefix": "while",
    "body": "while [[ ${1:condition} ]]; do\n\t${0}\ndone\n",
    "description": "A while loop by condition."
  },
  "until": {
    "prefix": "until",
    "body": "until [[ ${1:condition} ]]; do\n\t${0}\ndone\n",
    "description": "until loop by condition"
  },
  "function": {
    "prefix": "function",
    "body": "${1:name} ()\n{\n\t${0}\n}",
    "description": [
      "This defines a function named name.\n",
      "The reserved word function is optional.\n",
      "If the function reserved word is supplied, the parentheses are optional.\n",
      "1. Recommended way:\n",
      "name() {}\n",
      "2. C-like-way:\nfunction name [()] {}"
    ]
  },
  "case": {
    "prefix": "case",
    "body": "case \"$${0:VAR}\" in\n\t${1:1}) echo 1\n\t;;\n\t${2:2|3}) echo 2 or 3\n\t;;\n\t*) echo default\n\t;;\nesac\n",
    "description": [
      "case word in [ [(] pattern [ | pattern ] ... ) list ;; ] ... esac\n",
      "A case command first expands word, and tries to match it against each pattern in turn."
    ]
  },
  "break": {
    "prefix": "break",
    "body": "break ${0}",
    "description": [
      "The break command tells Bash to leave the loop straight away.\n",
      "Enter the break or break (n) where n=number of loops."
    ]
  },
  "expr": {
    "prefix": "expr",
    "body": "expr ${0:1 + 1}",
    "description": "Calculate numbers with Bash."
  },
  "shellcheck disable": {
    "prefix": [
      "shellcheck_disable",
      "disable_shellcheck",
      "ignore_shellcheck",
      "shellcheck_ignore"
    ],
    "body": ["# shellcheck disable=${0:code}"],
    "description": "Shellcheck disable"
  },
  "helper func": {
    "prefix": ["helper_func"],
    "body": [
      "",
      "# -----------------------------------------------------------------------------",
      "# START ${1}",
      "# -----------------------------------------------------------------------------",
      "",
      "${2}",
      "",
      "# -----------------------------------------------------------------------------",
      "# END ${1}",
      "# -----------------------------------------------------------------------------",
      ""
    ],
    "description": "Helper function"
  },
  "raise on no env": {
    "prefix": ["raise_on_no_env_file", "env_file_raise"],
    "body": [
      "function _raise_on_no_env_file {",
      "  if [[ -z \"\\$ENV_FILE\" ]]; then",
      "      echo -e \"\\nERROR: env file not set.\\n\"",
      "      exit 1",
      "  elif [[ \"\\$ENV_FILE\" =~ .env.example ]]; then",
      "      echo -e \"\\nERROR: env filename can not be .env.example.\\n\"",
      "      exit 1",
      "  fi",
      "}"
    ],
    "description": ["Raise on no env file"]
  },
  "browser sync start": {
    "prefix": ["browser_sync_start", "start_browser_sync"],
    "body": [
      "browser-sync start \\",
      "  --port \"browser-sync-port\" \\",
      "  --no-ui --no-open --no-notify \\",
      "  --proxy \"localhost:server_port\" \\",
      "  --files src/**/** \\",
      "  --files views/**/** \\",
      "  --files public/**/** &",
      "",
      "echo -n \"\\$!\" >./.___pid/browser-sync"
    ],
    "description": ["Browser sync start"]
  },
  "getopt parse options": {
    "prefix": ["getopt_parse_options", "parse_options_getopt"],
    "body": [
      "# --------------------------------------------------------------------------",
      "# PARSE ARGUMENTS",
      "# --------------------------------------------------------------------------",
      "local parsed",
      "",
      "if ! parsed=\"\\$(",
      "  getopt \\",
      "      --longoptions=help,dry,timeout: \\",
      "      --options=h,d,t: \\",
      "      --name \"\\$0\" \\",
      "      -- \"\\$@\"",
      ")\"; then",
      "  exit 1",
      "fi",
      "",
      "# Provides proper quoting",
      "eval set -- \"\\$parsed\"",
      "",
      "while true; do",
      "  case \"\\$1\" in",
      "    --help | -h)",
      "        ___helper-func",
      "        exit 0",
      "        ;;",
      "",
      "    --dry | -d)",
      "        dry=1",
      "        shift",
      "        ;;",
      "",
      "    --timeout | -t)",
      "        timeout=\\$2",
      "        shift 2",
      "        ;;",
      "",
      "    --)",
      "        shift",
      "        break",
      "        ;;",
      "",
      "    *)",
      "        Echo \"Unknown option \\${1}.\"",
      "        exit 1",
      "        ;;",
      "  esac",
      "done",
      "",
      "# handle non-option arguments",
      "if [[ \\$# -ne 1 ]]; then",
      "  echo \"\\$0: Non optional argument XX is required.\"",
      "  exit 1",
      "fi",
      "",
      "non_optional=\\$1",
      "# --------------------------------------------------------------------------",
      "# END PARSE ARGUMENTS",
      "# --------------------------------------------------------------------------"
    ],
    "description": ["getopt parse options"]
  },
  "define helper function": {
    "prefix": ["def_help_fun", "help_fun_def"],
    "body": [
      "function ___${1:name}-help {",
      "  : \"___help___ ___$1-help\"",
      "  read -r -d '' var <<'eof'",
      "${0:What does function do}. Usage:",
      "  ./run.sh ${2:func} [OPTIONS]",
      "",
      "Options:",
      "  --help/-h",
      "    Print this help text and quit.",
      "",
      "Examples:",
      "  # Get help.",
      "  ./run.sh ${2:func} --help",
      "",
      "  # Explanation of example.",
      "  ./run.sh ${2:func}",
      "eof",
      "",
      "  echo -e \"\\${var}\\n\"",
      "}"
    ],
    "description": ["define helper function"]
  },
  "define alias function": {
    "prefix": ["def_alias_func", "alias_func_def"],
    "body": [
      "function ${1:alias_name} {",
      "  : \"___alias___ ${2:main_func_name}\"",
      "    $2 \"\\${@}\"",
      "}"
    ],
    "description": ["define alias function"]
  },
  "Run.sh task template": {
    "prefix": ["task_template", "run_sh"],
    "body": [
      "#!/bin/bash",
      "# shellcheck disable=",
      "",
      "# set -o errexit",
      "set -o pipefail",
      "set -o noclobber",
      "",
      "# -----------------------------------------------------------------------------",
      "# For help text, you may use the form:",
      "# function func_name {",
      "#   : \"Some text 1\"",
      "#   : \"Some text 2\"",
      "# }",
      "#",
      "######## OR##################",
      "# function func_name {",
      "#   : \"___help___ ___some-func-help\"",
      "# }",
      "# The pattern is ___help___ ___name-help - the help function name must start",
      "# with `___` and end with `-help`",
      "#",
      "# For aliases:",
      "# function func_name {",
      "#   : \"___alias___ some-other-func\"",
      "# }",
      "# -----------------------------------------------------------------------------",
      "",
      "# -----------------------------------------------------------------------------",
      "# See also for inspiration:",
      "# https://github.com/nickjj/docker-flask-example/blob/main/run",
      "# -----------------------------------------------------------------------------",
      "",
      "# -----------------------------------------------------------------------------",
      "# Extend the search path so you can easily use executables that are not on the",
      "# normal search path",
      "# -----------------------------------------------------------------------------",
      "PATH=./node_modules/.bin:\\$PATH",
      "",
      "# -----------------------------------------------------------------------------",
      "# Helper functions start with _ and aren't listed in this script's help menu.",
      "# -----------------------------------------------------------------------------",
      "",
      "function _wait-until {",
      "  : \"Run 'command_to_run' and try until 'timeout' is reached. Usage:\"",
      "  : \"  ./run.sh _wait-until [OPTIONS] command_to_run\"",
      "  : \"  ./run.sh _wait-until command_to_run [OPTIONS]\"",
      "  : \"\"",
      "  : \"Options:\"",
      "  : \"  --sleep/-s.   How long (in seconds) to wait before command is tried again\"",
      "  : \"                when it fails. Defaults to 1 second.\"",
      "  : \"  --no-exit/-n. If true, we do not exit when timeout is reached but return.\"",
      "  : \"                This is great for situations where we want do not want the\"",
      "  : \"                script to exit if '_wait-until' does not run successfully.\"",
      "  : \"  --timeout/-t. How many retries before exiting/returning. Defaults to 30\"",
      "  : \"\"",
      "  : \"Examples:\"",
      "  : \"  ./run.sh _wait-until \"echo 'something'\"\"",
      "  : \"  ./run.sh _wait-until \"echo something\" --sleep 1 --timeout 2 --no-exit\"",
      "  : \"  ./run.sh _wait-until command_to_run -s 1 -t 2 -n\"",
      "",
      "  local _command=",
      "  local _timeout=30",
      "  local _sleep=1",
      "  local _no_exit=",
      "",
      "  # --------------------------------------------------------------------------",
      "  # PARSE ARGUMENTS",
      "  # --------------------------------------------------------------------------",
      "  local parsed",
      "",
      "  if ! parsed=\"\\$(",
      "      getopt \\",
      "          --longoptions=timeout:,sleep:,no-exit \\",
      "          --options=t:,s:,n \\",
      "          --name \"\\$0\" \\",
      "          -- \"\\$@\"",
      "  )\"; then",
      "      exit 1",
      "  fi",
      "",
      "  # Provides proper quoting",
      "  eval set -- \"\\$parsed\"",
      "",
      "  while true; do",
      "      case \"\\$1\" in",
      "          --timeout | -t)",
      "              _timeout=\"\\$2\"",
      "              shift 2",
      "              ;;",
      "",
      "          --sleep | -s)",
      "              _sleep=\"\\$2\"",
      "              shift 2",
      "              ;;",
      "",
      "          --no-exit | -n)",
      "              _no_exit=1",
      "              shift",
      "              ;;",
      "",
      "          --)",
      "              shift",
      "              break",
      "              ;;",
      "",
      "          *)",
      "              Echo \"Unknown option \\${1}.\"",
      "              exit 1",
      "              ;;",
      "      esac",
      "  done",
      "",
      "  # handle non-option arguments",
      "  if [[ \\$# -ne 1 ]]; then",
      "      echo \"\\$0: Non optional argument \\\"command\\\" is required.\"",
      "      exit 1",
      "  fi",
      "",
      "  _command=\\$1",
      "  # --------------------------------------------------------------------------",
      "  # END PARSE ARGUMENTS",
      "  # --------------------------------------------------------------------------",
      "",
      "  _echo \"Running: \\${_command}\"",
      "",
      "  i=0",
      "  until eval \"\\${_command}\"; do",
      "      ((i++))",
      "",
      "      if [ \"\\${i}\" -gt \"\\${_timeout}\" ]; then",
      "          echo \"Command '\\${_command}' failed due to \\${_timeout}s timeout!\"",
      "",
      "          if [[ -z \"\\${_no_exit}\" ]]; then",
      "              echo \"Aborting!\"",
      "              exit 1",
      "          else",
      "              return",
      "          fi",
      "      fi",
      "",
      "      sleep \"\\${_sleep}\"",
      "  done",
      "",
      "  _echo \"Done successfully running: \\${_command}\"",
      "}",
      "",
      "function _timestamp {",
      "  date +'%s'",
      "}",
      "",
      "function _raise-on-no-env {",
      "  if [[ ! -e \"\\${ENV_FILENAME}\" ]] ||",
      "      [[ \"\\${ENV_FILENAME}\" =~ .env.example ]]; then",
      "      echo -e \"Environment file does not exist or it's the wrong one.\"",
      "      exit 1",
      "  fi",
      "",
      "  local _required_envs=(",
      "      ENV1",
      "      ENV2",
      "  )",
      "",
      "  for _env_name in \"\\${_required_envs[@]}\"; do",
      "      printf -v _env_val \"%q\" \"\\${!_env_name}\"",
      "",
      "      if [ \"\\${_env_val}\" == \"''\" ]; then",
      "          echo -e \"'\\${_env_name}' environment variable is missing\"",
      "          exit 1",
      "      fi",
      "  done",
      "}",
      "",
      "function _has-internet {",
      "  ping -q -c 1 -W 1 8.8.8.8 >/dev/null",
      "}",
      "",
      "function _h {",
      "  # First and last newlines are required in order to pretty print help text",
      "  read -r -d '' var <<'eof'",
      "What does function do. Usage:",
      "  ./run.sh ping-app [OPTIONS]",
      "",
      "Options:",
      "  --verbose/-v. Description should be capitalized and end in a period.",
      "  --timeout/-t. Super long",
      "                              description's subsequent lines should start at same column as",
      "                              first line.",
      "",
      "Examples:",
      "  ./run.sh ping-app",
      "eof",
      "",
      "  local output",
      "  IFS=''",
      "  while read -r line; do",
      "      next=\": \\\"\\${line}\\\" \"",
      "      output=\"\\${output}\\n\\${next}\"",
      "  done <<<\"\\$(printf \"%s\" \"\\$var\")\"",
      "",
      "  echo -e \"\\${output}\\n\"",
      "",
      "  if command -v xclip &>/dev/null; then",
      "      echo -e \"\\${output}\" | xclip -selection c",
      "  fi",
      "}",
      "",
      "full_line_len=\\$(tput cols)",
      "",
      "function _echo {",
      "  local text=\"\\${*}\"",
      "  local equal='*'",
      "",
      "  local len=\"\\${#text}\"",
      "  len=\\$((full_line_len - len))",
      "  local half=\\$((len / 2 - 1))",
      "",
      "  local line=''",
      "",
      "  for _ in \\$(seq \\$half); do",
      "      line=\"\\${line}\\${equal}\"",
      "  done",
      "",
      "  echo -e \"\\n\\${text}  \\${line}\\${line}\\n\"",
      "}",
      "",
      "# -----------------------------------------------------------------------------",
      "# END HELPER FUNCTIONS",
      "# -----------------------------------------------------------------------------",
      "",
      "function d {",
      "  : \"Start development server\"",
      "",
      "  echo \"dev task not implemented\"",
      "}",
      "",
      "function help {",
      "  : \"List available tasks.\"",
      "",
      "  if [[ -z \"\\${1}\" ]]; then",
      "      mapfile -t names < <(compgen -A function | grep -v '^_')",
      "  else",
      "      mapfile -t names < <(compgen -A function | grep '^_')",
      "  fi",
      "",
      "  local _this_file_content",
      "  _this_file_content=\"\\$(cat \"\\${0}\")\"",
      "",
      "  local len=0",
      "  declare -A name_to_len_map=()",
      "",
      "  for name in \"\\${names[@]}\"; do",
      "      _len=\"\\${#name}\"",
      "      name_to_len_map[\"\\$name\"]=\"\\${_len}\"",
      "      if [[ \"\\${_len}\" -gt \"\\${len}\" ]]; then len=\\${_len}; fi",
      "  done",
      "",
      "  declare -A _all_output=()",
      "  declare -A _aliases=()",
      "  declare -A _name_spaces_map=()",
      "",
      "  len=\\$((len + 10))",
      "",
      "  for name in \"\\${names[@]}\"; do",
      "      if ! grep -qP \"function\\s+\\${name}\\s+{\" <<<\"\\${_this_file_content}\"; then",
      "          continue",
      "      fi",
      "",
      "      local spaces=\"\"",
      "      _len=\"\\${name_to_len_map[\\$name]}\"",
      "      _len=\\$((len - _len))",
      "",
      "      for _ in \\$(seq \"\\${_len}\"); do",
      "          spaces=\"\\${spaces}-\"",
      "          ((++t))",
      "      done",
      "",
      "      local _function_def_text",
      "      _function_def_text=\"\\$(type \"\\${name}\")\"",
      "",
      "      local _alias_name",
      "",
      "      # Matching pattern example:",
      "      # `: \"___alias___ install-elixir\"`",
      "      _alias_name=\"\\$(awk \\",
      "          'match(\\$0, /^ +: *\"___alias___ +([a-zA-Z_-][a-zA-Z0-9_-]*)/, a) {print a[1]}' \\",
      "          <<<\"\\${_function_def_text}\")\"",
      "",
      "      if [[ -n \"\\${_alias_name}\" ]]; then",
      "          _aliases[\"\\${_alias_name}\"]=\"\\${_aliases[\"\\${_alias_name}\"]} \\${name}\"",
      "          continue",
      "      fi",
      "",
      "      local _help_func=''",
      "",
      "      # Matching pattern example:",
      "      # `: \"___help___ ___elixir-help\"`",
      "      _help_func=\"\\$(awk \\",
      "          'match(\\$0, /^ +: *\"___help___ +(___[a-zA-Z][a-zA-Z0-9_-]*-help)/, a) {print a[1]}' \\",
      "          <<<\"\\${_function_def_text}\")\"",
      "",
      "      # Get the whole function definition text and extract only the documentation",
      "      # part.",
      "      if [[ -n \"\\${_help_func}\" ]]; then",
      "          mapfile -t _doc_lines < <(",
      "              eval \"\\${_help_func}\" 2>/dev/null",
      "          )",
      "      else",
      "          mapfile -t _doc_lines < <(",
      "              sed -nEe \"s/^[[:space:]]*: ?\\\"(.*)\\\";/\\1/p\" <<<\"\\${_function_def_text}\"",
      "          )",
      "      fi",
      "",
      "      local _output=\"\"",
      "",
      "      if [[ -n \"\\${_doc_lines[*]}\" ]]; then",
      "          for _doc in \"\\${_doc_lines[@]}\"; do",
      "              _output+=\"\\${name} \\${spaces} \\${_doc}\\n\"",
      "          done",
      "      else",
      "          _output=\"\\${name} \\${spaces} *************\\n\"",
      "      fi",
      "",
      "      _all_output[\"\\${name}\"]=\"\\${_output}\"",
      "      _name_spaces_map[\"\\${name}\"]=\"\\${name} \\${spaces}\"",
      "  done",
      "",
      "  for name in \"\\${!_all_output[@]}\"; do",
      "      _output=\"\\${_all_output[\"\\${name}\"]}\"",
      "      echo -e \"\\${_output}\"",
      "",
      "      local _alias_names=\"\\${_aliases[\"\\${name}\"]}\"",
      "",
      "      if [[ -n \"\\${_alias_names}\" ]]; then",
      "          echo -e \"\\${_name_spaces_map[\"\\${name}\"]} ALIASES: \\${_alias_names}\\n\\n\"",
      "      fi",
      "  done",
      "}",
      "",
      "TIMEFORMAT=\\$'\\n\\nTask completed in %3lR\\n'",
      "time \"\\${@:-help}\""
    ],
    "description": ["Run.sh task template"]
  }
}
